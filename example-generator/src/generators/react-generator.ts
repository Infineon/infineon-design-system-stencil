import * as fs from "node:fs";
import * as path from "node:path";
import { ReactCodeFormatter } from "../formatters/react-formatter.js";
import type {
	GenerationResult,
	GeneratorConfig,
	IExampleGenerator,
} from "../interfaces.js";
import type { ComponentInfo } from "../types.js";
import { FileUpdater } from "../utils/file-updater.js";
import { formatTitle, toPascalCase } from "../utils/string-utils.js";

/**
 * React example generator
 */
export class ReactExampleGenerator implements IExampleGenerator {
	private formatter: ReactCodeFormatter;
	private fileUpdater: FileUpdater;

	constructor() {
		this.formatter = new ReactCodeFormatter();
		this.fileUpdater = new FileUpdater();
	}

	/**
	 * Generate React examples
	 */
	generate(
		components: ComponentInfo[],
		config: GeneratorConfig,
	): GenerationResult {
		const result: GenerationResult = {
			success: true,
			filesGenerated: [],
			filesUpdated: [],
			errors: [],
		};

		try {
			// Ensure directory structure exists
			this.ensureDirectoryStructure(config.outputDir);

			// Generate component files
			const imports: string[] = [];
			const componentJSX: string[] = [];

			for (const component of components) {
				const componentName = toPascalCase(component.component);
				const storyNameSuffix =
					component.storyName && component.storyName !== "Default"
						? component.storyName.replace(/\s+/g, "")
						: "";
				const componentClassName = `${componentName}${storyNameSuffix}Example`;
				const componentCode = this.formatter.formatComponentFile(component);
				const filePath = path.join(
					config.outputDir,
					"src",
					"generated",
					`${componentClassName}.tsx`,
				);

				fs.writeFileSync(filePath, componentCode);
				result.filesGenerated.push(filePath);

				// Prepare imports and JSX for App.tsx
				const idSuffix =
					component.storyName && component.storyName !== "Default"
						? `-${component.storyName.toLowerCase().replace(/\s+/g, "-")}`
						: "";
				imports.push(
					`import { ${componentClassName} } from './generated/${componentClassName}';`,
				);
				componentJSX.push(
					`<section id="${component.component}-example${idSuffix}" className="component-example">\n` +
						`  <h2>${formatTitle(component.title, component.component, component.storyName)}</h2>\n` +
						`  <div className="demo">\n` +
						`    <${componentClassName} />\n` +
						`  </div>\n` +
						`</section>`,
				);
			}

			// Update App.tsx
			const appPath = path.join(config.outputDir, "src", "App.tsx");

			if (!this.validate(config)) {
				result.success = false;
				result.errors?.push(`App.tsx not found or missing markers: ${appPath}`);
				return result;
			}

			const importsContent = imports.join("\n");
			const componentsContent = componentJSX.join("\n\n");
			const wrappedComponents = `<>\n${componentsContent}\n</>`;

			const updated = this.fileUpdater.updateFile(appPath, {
				imports: importsContent,
				components: wrappedComponents,
			});

			if (updated) {
				result.filesUpdated.push(appPath);
			}
		} catch (error) {
			result.success = false;
			result.errors?.push(
				error instanceof Error ? error.message : String(error),
			);
		}

		return result;
	}

	/**
	 * Get generator name
	 */
	getName(): string {
		return "React";
	}

	/**
	 * Validate output directory and file structure
	 */
	validate(config: GeneratorConfig): boolean {
		const appPath = path.join(config.outputDir, "src", "App.tsx");

		return this.fileUpdater.hasMarkers(appPath, [
			"/* <AUTO-GENERATED-IMPORTS> */",
			"/* </AUTO-GENERATED-IMPORTS> */",
			"/* <AUTO-GENERATED-COMPONENTS> */",
			"/* </AUTO-GENERATED-COMPONENTS> */",
		]);
	}

	/**
	 * Ensure directory structure exists
	 */
	private ensureDirectoryStructure(outputDir: string): void {
		const dirs = [
			outputDir,
			path.join(outputDir, "src"),
			path.join(outputDir, "src", "generated"),
		];

		dirs.forEach((dir) => {
			if (!fs.existsSync(dir)) {
				fs.mkdirSync(dir, { recursive: true });
			}
		});
	}
}
