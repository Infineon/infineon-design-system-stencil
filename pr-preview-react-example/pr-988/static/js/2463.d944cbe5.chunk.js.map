{"version":3,"file":"static/js/2463.d944cbe5.chunk.js","mappings":"8KAAA,MCOaA,EAAkB,M,oGAuB7B,KAAAC,iBAAmB,KACKC,KAAKC,GAAGC,WAAWC,cAAc,iCACmBC,iBAAiB,CAAEC,SAAS,IAGvEC,SAAQC,IACpBA,EAAiBC,iBAAiB,YAE1CF,SAASG,IAChBA,EAAeC,cAAgBD,EAAeC,YAAY,GAC1D,IAGqBV,KAAKC,GAAGC,WAAWC,cAAc,8BACgBC,iBAAiB,CAAEC,SAAS,IAE1EC,SAASK,IACnC,MAEMC,EAFeD,EAAoBR,cAAc,qBAEtBD,WAAWM,iBAAiB,oBAEzDI,EAAYC,OAAS,GACvBD,EAAYN,SAASQ,IACnBA,EAAmBC,MAAQ,EAAE,G,IAMnCf,KAAKgB,gBAAkB,GAGvBhB,KAAKiB,uBAAuBC,KAAKlB,KAAKgB,gBAAgB,EAKxD,KAAAG,sBAAyBC,IACvBpB,KAAKqB,mBAAmBD,EAAM,EAGhC,KAAAE,mBAAsBF,IAEpBpB,KAAKqB,mBAAmBD,EAAM,EAIhC,KAAAC,mBAAsBD,IAEpB,MAAMG,EAAqB,IAAIvB,KAAKgB,iBAGpC,GAAmB,0BAAfI,EAAMI,KAAkC,CAE1C,MAAM,WAAEC,EAAU,YAAEC,GAAgBN,EAAMO,OAGpCC,EAAsBL,EAAmBM,WAAUC,GAA4B,kBAAXA,GAAuBA,EAAOC,kBAAoBN,KAE/F,IAAzBG,EAEFL,EAAmBK,GAAqBb,MAAQW,EAGhDH,EAAmBS,KAAK,CAAED,gBAAiBN,EAAYV,MAAOW,G,MAE3D,GAAmB,6BAAfN,EAAMI,KAAqC,CACpD,MAAM,gBAAEO,EAAe,cAAEE,GAAkBb,EAAMO,OAG3CC,EAAsBL,EAAmBM,WAAUC,GAAUA,EAAOC,kBAAoBA,KAEjE,IAAzBH,EAEFL,EAAmBK,GAAuB,CAAEG,kBAAiBE,iBAG7DV,EAAmBS,KAAK,CAAED,kBAAiBE,iB,CAK/CjC,KAAKgB,gBAAkBO,EAGvBvB,KAAKiB,uBAAuBC,KAAKlB,KAAKgB,gBAAgB,E,qBA1G+F,E,CAOvJkB,iBAAAA,GACElC,KAAKC,GAAGkC,iBAAiB,2BAA4BnC,KAAKmB,uBAC1DnB,KAAKC,GAAGkC,iBAAiB,wBAAyBnC,KAAKsB,oBACvDc,OAAOD,iBAAiB,uBAAwBnC,KAAKD,iB,CAKvDsC,mBAAAA,GACErC,KAAKC,GAAGqC,oBAAoB,2BAA4BtC,KAAKmB,uBAC7DnB,KAAKC,GAAGqC,oBAAoB,wBAAyBtC,KAAKsB,oBAC1Dc,OAAOE,oBAAoB,uBAAwBtC,KAAKD,iB,CA2F1DwC,MAAAA,GACE,OACEC,EAAAA,EAAAA,GAACC,EAAAA,EAAI,CAAAC,IAAA,6CACHF,EAAAA,EAAAA,GAAA,OAAAE,IAAA,2CAAKC,MAAM,sBACTH,EAAAA,EAAAA,GAAA,QAAAE,IAAA,2CAAME,KAAK,mBACXJ,EAAAA,EAAAA,GAAA,QAAAE,IAAA,2CAAME,KAAK,sB,wCD3HM,yG","sources":["../node_modules/@infineon/infineon-design-system-stencil/dist/esm/src/components/filter-type-group/filter-type-group.scss?tag=ifx-filter-type-group&encapsulation=shadow","../node_modules/@infineon/infineon-design-system-stencil/dist/esm/src/components/filter-type-group/filter-type-group.tsx"],"sourcesContent":["@use \"~@infineon/design-system-tokens/dist/tokens\";\n\n\n:host {\n  display: flex;\n}\n\n.filter-type-group {\n  width: 260px;\n  flex-direction: column;\n  align-items: flex-start;\n  gap: tokens.$ifxSpace100;\n}","import { Component, h, State, Event, EventEmitter, Element, Host } from '@stencil/core';\n\n@Component({\n  tag: 'ifx-filter-type-group',\n  styleUrl: 'filter-type-group.scss',\n  shadow: true,\n})\nexport class IfxFilterTypeGroup {\n  @Element() el: HTMLElement;\n  @State() selectedOptions: Array<{ filterGroupName: string, selectedItems?: Array<{ filterName: string, value: boolean | string }>, value?: string }> = [];\n  @Event() ifxSidebarFilterChange: EventEmitter;\n\n\n\n/* If the component is ever removed and then reattached to the DOM, \nconnectedCallback ensures that the event listeners are properly set up again */\n  connectedCallback() {\n    this.el.addEventListener('ifxFilterAccordionChange', this.handleAccordionChange);\n    this.el.addEventListener('ifxFilterSearchChange', this.handleSearchChange);\n    window.addEventListener('ifxResetFiltersEvent', this.handleResetEvent);\n\n  }\n\n\n  componentWillUnload() {\n    this.el.removeEventListener('ifxFilterAccordionChange', this.handleAccordionChange);\n    this.el.removeEventListener('ifxFilterSearchChange', this.handleSearchChange);\n    window.removeEventListener('ifxResetFiltersEvent', this.handleResetEvent);\n  }\n\n  handleResetEvent = () => {\n    const accordionSlot = this.el.shadowRoot.querySelector('slot[name=\"filter-accordion\"]');\n    const filterAccordionSlottedElements = (accordionSlot as HTMLSlotElement).assignedElements({ flatten: true });\n\n\n    filterAccordionSlottedElements.forEach(accordionElement => {\n      const ifxLists = accordionElement.querySelectorAll('ifx-list');\n    \n      ifxLists.forEach((ifxListElement: HTMLIfxListElement) => {\n        ifxListElement.resetTrigger = !ifxListElement.resetTrigger;\n      });\n    });\n    \n    const filterSearchSlot = this.el.shadowRoot.querySelector('slot[name=\"filter-search\"]');\n    const filterSearchSlottedElements = (filterSearchSlot as HTMLSlotElement).assignedElements({ flatten: true });\n\n    filterSearchSlottedElements.forEach((filterSearchWrapper: HTMLElement) => {\n      const filterSearch = filterSearchWrapper.querySelector('ifx-filter-search');\n\n      const searchField = filterSearch.shadowRoot.querySelectorAll('ifx-search-field')\n\n      if (searchField.length > 0) {\n        searchField.forEach((searchFieldElement: any) => {\n          searchFieldElement.value = '';\n        });\n\n      }\n    });\n\n    this.selectedOptions = [];\n\n    // Emit the change to inform any parent components that the filters have been reset\n    this.ifxSidebarFilterChange.emit(this.selectedOptions);\n  }\n\n\n\n  handleAccordionChange = (event: CustomEvent) => {\n    this.handleFilterChange(event);\n  }\n\n  handleSearchChange = (event: CustomEvent) => {\n    // Call handleFilterChange with the created CustomEvent object\n    this.handleFilterChange(event);\n  }\n\n\n  handleFilterChange = (event: CustomEvent) => {\n    // Create a new array to hold the new state\n    const newSelectedOptions = [...this.selectedOptions];\n\n    // Check the type of the event\n    if (event.type === 'ifxFilterSearchChange') {\n      // Handle the ifxFilterSearchChange event\n      const { filterName, filterValue } = event.detail;\n\n      // Find the existing filter with the same filterName\n      const existingOptionIndex = newSelectedOptions.findIndex(option => typeof option !== 'string' && option.filterGroupName === filterName);\n\n      if (existingOptionIndex !== -1) {\n        // If an existing filter is found, update its value\n        newSelectedOptions[existingOptionIndex].value = filterValue;\n      } else {\n        // If no existing filter is found, append the new filter\n        newSelectedOptions.push({ filterGroupName: filterName, value: filterValue });\n      }\n    } else if (event.type === 'ifxFilterAccordionChange') {\n      const { filterGroupName, selectedItems } = event.detail;\n\n      // Find the existing filter group with the same filterGroupName\n      const existingOptionIndex = newSelectedOptions.findIndex(option => option.filterGroupName === filterGroupName);\n\n      if (existingOptionIndex !== -1) {\n        // If an existing filter group is found, update its selectedItems\n        newSelectedOptions[existingOptionIndex] = { filterGroupName, selectedItems };\n      } else {\n        // If no existing filter group is found, append the new filter group\n        newSelectedOptions.push({ filterGroupName, selectedItems });\n      }\n    }\n\n    // Update the state with the new selected options\n    this.selectedOptions = newSelectedOptions;\n\n    // Emit the entire selectedOptions array\n    this.ifxSidebarFilterChange.emit(this.selectedOptions);\n  }\n\n  render() {\n    return (\n      <Host>\n        <div class=\"filter-type-group\">\n          <slot name=\"filter-search\" />\n          <slot name=\"filter-accordion\" />\n        </div>\n      </Host>\n    );\n  }\n}"],"names":["IfxFilterTypeGroup","handleResetEvent","this","el","shadowRoot","querySelector","assignedElements","flatten","forEach","accordionElement","querySelectorAll","ifxListElement","resetTrigger","filterSearchWrapper","searchField","length","searchFieldElement","value","selectedOptions","ifxSidebarFilterChange","emit","handleAccordionChange","event","handleFilterChange","handleSearchChange","newSelectedOptions","type","filterName","filterValue","detail","existingOptionIndex","findIndex","option","filterGroupName","push","selectedItems","connectedCallback","addEventListener","window","componentWillUnload","removeEventListener","render","h","Host","key","class","name"],"sourceRoot":""}