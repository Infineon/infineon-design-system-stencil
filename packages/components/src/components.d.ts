/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { ActionListItemClickEvent } from "./components/action-list/action-list-item";
import { ChipItemSelectEvent, ChipState } from "./components/chip/interfaces";
import { ChangeEvent } from "./components/content-switcher/content-switcher";
import { Placement } from "./components/dropdown/dropdown";
import { IOpenable } from "./components/dropdown/IOpenable";
import { NotificationVariant } from "./components/notification/notification";
import { SuggestionItem } from "./components/search-field/search-field";
import { AddItemTextFn, AjaxFn, ClassNames, CustomAddItemText, FuseOptions, ItemFilterFn, MaxItemTextFn, NoChoicesTextFn, NoResultsTextFn, OnCreateTemplates, OnInit, SortFn, UniqueItemText, ValueCompareFunction } from "./components/select/single-select/interfaces";
import { StepperState } from "./components/stepper/interfaces";
import { Event } from "@stencil/core";
import { TreeViewCheckChangeEvent, TreeViewDisableChangeEvent, TreeViewExpandChangeEvent } from "./components/tree-view/tree-view-item";
export { ActionListItemClickEvent } from "./components/action-list/action-list-item";
export { ChipItemSelectEvent, ChipState } from "./components/chip/interfaces";
export { ChangeEvent } from "./components/content-switcher/content-switcher";
export { Placement } from "./components/dropdown/dropdown";
export { IOpenable } from "./components/dropdown/IOpenable";
export { NotificationVariant } from "./components/notification/notification";
export { SuggestionItem } from "./components/search-field/search-field";
export { AddItemTextFn, AjaxFn, ClassNames, CustomAddItemText, FuseOptions, ItemFilterFn, MaxItemTextFn, NoChoicesTextFn, NoResultsTextFn, OnCreateTemplates, OnInit, SortFn, UniqueItemText, ValueCompareFunction } from "./components/select/single-select/interfaces";
export { StepperState } from "./components/stepper/interfaces";
export { Event } from "@stencil/core";
export { TreeViewCheckChangeEvent, TreeViewDisableChangeEvent, TreeViewExpandChangeEvent } from "./components/tree-view/tree-view-item";
export namespace Components {
    interface IfxAccordion {
        /**
          * @default false
         */
        "autoCollapse": boolean;
    }
    interface IfxAccordionItem {
        /**
          * @default 3
         */
        "AriaLevel": 3;
        "caption": string;
        /**
          * @default false
         */
        "open": boolean;
    }
    interface IfxActionList {
        /**
          * Aria label for accessibility support
         */
        "listAriaLabel"?: string;
    }
    interface IfxActionListItem {
        /**
          * The description text displayed below the title
         */
        "description"?: string;
        /**
          * Controls whether the item is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * URL to navigate to when item is clicked
         */
        "href"?: string;
        /**
          * Aria label for accessibility support
         */
        "itemAriaLabel"?: string;
        /**
          * The title text displayed in the item
         */
        "itemTitle": string;
        /**
          * Target for the link navigation
          * @default '_self'
         */
        "target": string;
        /**
          * Value associated with this item
         */
        "value"?: string;
    }
    interface IfxAiLabel {
        /**
          * Determines whether to show a divider line
          * @default true
         */
        "divider": boolean;
        /**
          * Display variant - either label or icon
          * @default 'label'
         */
        "variant": 'label' | 'icon';
    }
    interface IfxAlert {
        /**
          * @default "assertive"
         */
        "AriaLive": "assertive";
        /**
          * @default true
         */
        "closable": boolean;
        "icon": string;
        /**
          * @default "primary"
         */
        "variant": "primary" | "success" | "danger" | "warning" | "info";
    }
    interface IfxBasicTable {
        "cols": any[] | string;
        /**
          * @default "default"
         */
        "rowHeight": string;
        "rows": any[] | string;
        /**
          * @default "auto"
         */
        "tableHeight": string;
        /**
          * @default "default"
         */
        "variant": string;
    }
    interface IfxBreadcrumb {
    }
    interface IfxBreadcrumbItem {
    }
    interface IfxBreadcrumbItemLabel {
        "href": string;
        "icon": string;
        /**
          * @default "_self"
         */
        "target": string;
    }
    interface IfxButton {
        "ariaLabel": string | null;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "fullWidth": boolean;
        "href": string;
        "setFocus": () => Promise<void>;
        /**
          * @default "m"
         */
        "size": string;
        /**
          * @default "_self"
         */
        "target": string;
        /**
          * @default "default"
         */
        "theme": "default" | "danger" | "inverse";
        /**
          * @default "button"
         */
        "type": "button" | "submit" | "reset";
        /**
          * @default "primary"
         */
        "variant": "primary" | "secondary" | "tertiary";
    }
    interface IfxCard {
        "ariaLabel": string | null;
        /**
          * @default "vertical"
         */
        "direction": "horizontal" | "vertical";
        /**
          * @default ""
         */
        "href": string;
        /**
          * @default "_self"
         */
        "target": string;
    }
    interface IfxCardHeadline {
    }
    interface IfxCardImage {
        "alt": string;
        "position": string;
        "src": string;
    }
    interface IfxCardLinks {
    }
    interface IfxCardOverline {
    }
    interface IfxCardText {
    }
    interface IfxCheckbox {
        /**
          * The state of the checkbox. When true, the checkbox is checked; when false, it is unchecked.
          * @default false
         */
        "checked": boolean;
        /**
          * Indicates whether the checkbox is disabled. When true, the checkbox cannot be interacted with and will have a disabled appearance.
          * @default false
         */
        "disabled": boolean;
        /**
          * Indicates whether the checkbox is in an error state. When true, the checkbox will have an error appearance.
          * @default false
         */
        "error": boolean;
        /**
          * Indicates whether the checkbox is in an indeterminate state. When true, the checkbox will have an indeterminate appearance, which is typically used to indicate a "partially selected" state in a group of checkboxes.
          * @default false
         */
        "indeterminate": boolean;
        /**
          * Method to get the current checked state of the checkbox.
          * @returns A promise that resolves to a boolean indicating whether the checkbox is checked.
         */
        "isChecked": () => Promise<boolean>;
        /**
          * Method to set the checked state of the checkbox.
          * @param newVal A boolean value to set the checked state of the checkbox.
          * @returns A promise that resolves when the checked state has been updated.
         */
        "setChecked": (newVal: boolean) => Promise<void>;
        /**
          * The size of the checkbox. Can be "m" for medium (default) or "s" for small. This prop controls the overall dimensions of the checkbox and its label.
          * @default "m"
         */
        "size": string;
        /**
          * Toggles the checked state.
          * @returns Resolves when the toggle is complete.
         */
        "toggle": () => Promise<boolean>;
        /**
          * @deprecated Use `setChecked` instead.
         */
        "toggleCheckedState": (newVal: boolean) => Promise<void>;
        /**
          * The value associated with the checkbox.  This value is typically submitted with a form when the checkbox is checked.  If not specified, it defaults to "on" when the checkbox is checked.
         */
        "value": string;
    }
    interface IfxCheckboxGroup {
        /**
          * @default "vertical"
         */
        "alignment": "horizontal" | "vertical";
        "captionText": string;
        /**
          * @default "Group Label Text"
         */
        "groupLabelText": string;
        /**
          * @default false
         */
        "required": boolean;
        "setGroupError": (error: boolean) => Promise<void>;
        "showCaption": boolean;
        "showCaptionIcon": boolean;
        "showGroupLabel": boolean;
        "size": string;
    }
    interface IfxChip {
        "ariaLabel": string | null;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default ""
         */
        "icon": string;
        /**
          * @default ""
         */
        "placeholder": string;
        /**
          * @default false
         */
        "readOnly": boolean;
        /**
          * @default "medium"
         */
        "size": "small" | "medium" | "large";
        /**
          * @default "outlined"
         */
        "theme": "outlined" | "filled-light" | "filled-dark";
        /**
          * @default undefined
         */
        "value": Array<string> | string;
        /**
          * @default "single"
         */
        "variant": "single" | "multi";
    }
    interface IfxChipItem {
        /**
          * @default { 		emitIfxChipItemSelect: true, 		variant: "multi", 		size: "large", 	}
         */
        "chipState": ChipState;
        /**
          * @default false
         */
        "selected": boolean;
        /**
          * @default undefined
         */
        "value": string;
    }
    interface IfxContentSwitcher {
    }
    interface IfxContentSwitcherItem {
        /**
          * @default false
         */
        "selected": boolean;
        "value": string;
    }
    interface IfxDatePicker {
        /**
          * Aria label for the date picker input
         */
        "ariaLabelText": string | null;
        /**
          * Autocomplete attribute for the input
          * @default "on"
         */
        "autocomplete": string;
        /**
          * Caption text displayed below the date picker
         */
        "caption": string;
        /**
          * Clears the date picker value
         */
        "clear": () => Promise<void>;
        /**
          * Whether the date picker is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Error state of the date picker
          * @default false
         */
        "error": boolean;
        /**
          * Label text for the date picker
         */
        "label": string;
        /**
          * Maximum allowed date
         */
        "max": string;
        /**
          * Minimum allowed date
         */
        "min": string;
        /**
          * Whether the date picker is required
          * @default false
         */
        "required": boolean;
        /**
          * Size of the date picker input
          * @default "s"
         */
        "size": string;
        /**
          * Success state of the date picker
          * @default false
         */
        "success": boolean;
        /**
          * Type of date input (date, datetime-local, etc.)
          * @default "date"
         */
        "type": string;
        /**
          * The value of the date picker
         */
        "value": string;
    }
    interface IfxDownload {
        /**
          * @default "css"
         */
        "tokens": "css" | "scss";
    }
    interface IfxDropdown {
        "closeDropdown": () => Promise<void>;
        /**
          * @default false
         */
        "defaultOpen": boolean;
        "disabled": boolean;
        "isOpen": () => Promise<boolean>;
        /**
          * @default false
         */
        "noAppendToBody": boolean;
        /**
          * @default false
         */
        "noCloseOnMenuClick": boolean;
        /**
          * @default false
         */
        "noCloseOnOutsideClick": boolean;
        "openDropdown": () => Promise<void>;
        /**
          * @default "bottom-start"
         */
        "placement": Placement;
    }
    interface IfxDropdownHeader {
    }
    interface IfxDropdownItem {
        /**
          * @default false
         */
        "error": boolean;
        /**
          * @default false
         */
        "hide": boolean;
        /**
          * @default ""
         */
        "href": string;
        "icon": string;
        /**
          * @default "_self"
         */
        "target": string;
    }
    interface IfxDropdownMenu {
        /**
          * @default false
         */
        "isOpen": boolean;
        /**
          * @default "l"
         */
        "size": string;
    }
    interface IfxDropdownSeparator {
    }
    interface IfxDropdownTrigger {
        /**
          * @default false
         */
        "isOpen": boolean;
    }
    interface IfxDropdownTriggerButton {
        "disabled": boolean;
        /**
          * @default false
         */
        "hideArrow": boolean;
        /**
          * @default false
         */
        "isOpen": boolean;
        /**
          * @default "m"
         */
        "size": "s" | "m";
        /**
          * @default "default"
         */
        "theme": "default" | "danger" | "inverse";
        "variant": "primary";
    }
    interface IfxFaq {
    }
    interface IfxFileUpload {
        /**
          * @default []
         */
        "additionalAllowedFileTypes"?: string | string[];
        /**
          * When set to true, allows any file type to be uploaded (no file type restrictions).
          * @default false
         */
        "allowAnyFileType": boolean;
        /**
          * Custom file extensions to allow (e.g., 'xml', 'asc', 'cfg'). Recommended format: without dots. Also accepts format with dots like '.xml'. Do not use wildcards like '*.xml'.
          * @default []
         */
        "allowedFileExtensions"?: string | string[];
        /**
          * Default set of allowed file extensions (used internally). Can be extended using `additionalAllowedFileTypes`.
          * @default undefined
         */
        "allowedFileTypes"?: string | string[];
        /**
          * @default "Browse files"
         */
        "ariaLabelBrowseFiles": string;
        /**
          * @default "Cancel upload"
         */
        "ariaLabelCancelUpload": string;
        /**
          * @default "Upload area. Click to browse or drag and drop files."
         */
        "ariaLabelDropzone": string;
        /**
          * @default "Upload file"
         */
        "ariaLabelFileInput": string;
        /**
          * @default "Remove file"
         */
        "ariaLabelRemoveFile": string;
        /**
          * @default "Retry upload"
         */
        "ariaLabelRetryUpload": string;
        /**
          * @default "Upload failed"
         */
        "ariaLabelUploadFailedStatus": string;
        /**
          * @default "Upload completed"
         */
        "ariaLabelUploadedStatus": string;
        /**
          * @default "Upload in progress"
         */
        "ariaLabelUploadingStatus": string;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "dragAndDrop": boolean;
        "injectDemoState": () => Promise<void>;
        /**
          * @default "Label"
         */
        "label": string;
        /**
          * @default "Browse files"
         */
        "labelBrowseFiles": string;
        /**
          * @default "Drag & Drop or browse files to upload"
         */
        "labelDragAndDrop": string;
        /**
          * @default "files"
         */
        "labelFilePlural": string;
        /**
          * @default "file"
         */
        "labelFileSingular": string;
        /**
          * @default "Upload failed. Max file size: {{size}}MB."
         */
        "labelFileTooLarge": string;
        /**
          * @default "Upload limit exceeded. Only {{count}} {{files}} allowed."
         */
        "labelMaxFilesExceeded": string;
        /**
          * @default "Up to {{count}} {{files}}."
         */
        "labelMaxFilesInfo"?: string;
        /**
          * @default "At least one file must be uploaded"
         */
        "labelRequiredError": string;
        /**
          * @default "Supported file formats: {{types}}. Max file size: {{size}}MB."
         */
        "labelSupportedFormatsTemplate": string;
        /**
          * @default "Unsupported file type."
         */
        "labelUnsupportedFileType": string;
        /**
          * @default "Upload failed. Please try again."
         */
        "labelUploadFailed": string;
        /**
          * @default "Successfully uploaded"
         */
        "labelUploaded": string;
        /**
          * @default "Uploaded files"
         */
        "labelUploadedFilesHeading": string;
        /**
          * @default 7
         */
        "maxFileSizeMB": number;
        "maxFiles": number | undefined;
        /**
          * @default false
         */
        "required": boolean;
        "triggerDemoValidation": () => Promise<void>;
        "uploadHandler"?: (
		file: File,
		onProgress?: (progress: number) => void,
	) => Promise<void>;
    }
    interface IfxFilterAccordion {
        /**
          * @default ""
         */
        "filterGroupName": "";
        "maxVisibleItems": number;
    }
    interface IfxFilterBar {
        /**
          * @default 4
         */
        "maxShownFilters": number;
        /**
          * @default true
         */
        "showMoreFiltersButton": boolean;
    }
    interface IfxFilterSearch {
        /**
          * @default false
         */
        "disabled": boolean;
        "filterKey": string;
        "filterName": string;
        /**
          * @default "sidebar"
         */
        "filterOrientation": string;
        "filterValue": string;
        "placeholder": string;
    }
    interface IfxFilterTypeGroup {
    }
    interface IfxFooter {
        /**
          * @default "© 1999 - " + this.currentYear + " Infineon Technologies AG"
         */
        "copyrightText": string;
    }
    interface IfxFooterColumn {
    }
    interface IfxIcon {
        /**
          * @default ""
         */
        "icon": string;
        "ifxIcon": any;
    }
    interface IfxIconButton {
        "ariaLabel": string | null;
        "disabled": boolean;
        "href": string;
        "icon": string;
        "setFocus": () => Promise<void>;
        /**
          * @default "round"
         */
        "shape": string;
        "size": string;
        /**
          * @default "_self"
         */
        "target": string;
        "variant": "primary" | "secondary" | "tertiary";
    }
    interface IfxIconsPreview {
    }
    interface IfxIndicator {
        "ariaLabel": string | null;
        /**
          * @default false
         */
        "inverted": boolean;
        /**
          * @default 0
         */
        "number": number;
        /**
          * @default "number"
         */
        "variant": string;
    }
    interface IfxLink {
        "ariaLabel": string | null;
        /**
          * @default false
         */
        "disabled": boolean;
        "download": string;
        /**
          * @default undefined
         */
        "href": string;
        "size": string;
        /**
          * @default "_self"
         */
        "target": string;
        /**
          * @default "bold"
         */
        "variant": string;
    }
    interface IfxList {
        /**
          * @default 6
         */
        "maxVisibleItems": 6;
        /**
          * @default ""
         */
        "name": "";
        "resetTrigger": boolean;
        /**
          * @default "checkbox"
         */
        "type": string;
    }
    interface IfxListEntry {
        "label": string;
        "type": string;
        "value": boolean;
    }
    interface IfxModal {
        /**
          * @default ""
         */
        "alertIcon": string;
        /**
          * @default "Cancel"
         */
        "cancelButtonLabel": string;
        /**
          * @default "Modal Title"
         */
        "caption": string;
        "captionAriaLabel": string | null;
        "closeButtonAriaLabel": string | null;
        /**
          * @default true
         */
        "closeOnOverlayClick": boolean;
        /**
          * @default "OK"
         */
        "okButtonLabel": string;
        /**
          * @default false
         */
        "opened"?: boolean;
        /**
          * @default true
         */
        "showCloseButton": boolean;
        /**
          * @default "s"
         */
        "size": "s" | "m" | "l";
        /**
          * @default "default"
         */
        "variant": "default" | "alert-brand" | "alert-danger";
    }
    interface IfxMultiselect {
        /**
          * @default "Clear all selections"
         */
        "ariaClearLabel": string;
        /**
          * @default "Collapse all categories"
         */
        "ariaCollapseAllLabel": string;
        /**
          * @default "Expand all categories"
         */
        "ariaExpandAllLabel": string;
        /**
          * @default ""
         */
        "ariaMultiSelectDescribedBy": string;
        /**
          * @default "Multi-select dropdown"
         */
        "ariaMultiSelectLabel": string;
        /**
          * @default ""
         */
        "ariaMultiSelectLabelledBy": string;
        /**
          * @default "Search options"
         */
        "ariaSearchLabel": string;
        /**
          * @default "Select all options"
         */
        "ariaSelectAllLabel": string;
        /**
          * @default "Toggle dropdown"
         */
        "ariaToggleLabel": string;
        /**
          * @default ""
         */
        "caption": string;
        "clearSelection": () => Promise<void>;
        /**
          * @default "Collapse"
         */
        "collapseLabel": string;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "error": boolean;
        /**
          * @default "Expand"
         */
        "expandLabel": string;
        /**
          * @default ""
         */
        "label": string;
        "name": string;
        /**
          * @default "No results found."
         */
        "noResultsMessage": string;
        /**
          * @default ""
         */
        "placeholder": string;
        /**
          * @default false
         */
        "required": boolean;
        /**
          * @default "Search"
         */
        "searchPlaceholder": string;
        /**
          * @default "Select all"
         */
        "selectAllLabel": string;
        /**
          * @default true
         */
        "showClearButton": boolean;
        /**
          * @default true
         */
        "showExpandCollapse": boolean;
        /**
          * @default true
         */
        "showNoResultsMessage": boolean;
        /**
          * @default true
         */
        "showSearch": boolean;
        /**
          * @default true
         */
        "showSelectAll": boolean;
    }
    interface IfxMultiselectOption {
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "indeterminate": boolean;
        /**
          * @default false
         */
        "selected": boolean;
        "value": string;
    }
    interface IfxNavbar {
        /**
          * @default ""
         */
        "applicationName": string;
        /**
          * @default true
         */
        "fixed": boolean;
        /**
          * @default ""
         */
        "logoHref": string;
        /**
          * @default "_self"
         */
        "logoHrefTarget": string;
        /**
          * @default true
         */
        "showLogoAndAppname": boolean;
    }
    interface IfxNavbarItem {
        "addMenuItemClass": () => Promise<void>;
        /**
          * @default false
         */
        "dotIndicator": boolean;
        "hideComponent": () => Promise<void>;
        /**
          * @default true
         */
        "hideOnMobile": boolean;
        /**
          * @default ""
         */
        "href": string;
        /**
          * @default ""
         */
        "icon": string;
        "moveChildComponentsBackIntoNavbar": () => Promise<void>;
        "moveChildComponentsIntoSubLayerMenu": () => Promise<void>;
        "numberIndicator": number;
        "returnToFirstLayer": () => Promise<void>;
        "setItemSideSpecifications": () => Promise<boolean>;
        "setMenuItemPosition": () => Promise<void>;
        "showComponent": () => Promise<void>;
        /**
          * @default true
         */
        "showLabel": boolean;
        /**
          * @default "_self"
         */
        "target": string;
        "toggleChildren": (action: any) => Promise<void>;
        "toggleFirstLayerItem": (actionOne: any, actionTwo: any) => Promise<void>;
    }
    interface IfxNavbarProfile {
        /**
          * @default ""
         */
        "alt": string;
        "hideComponent": () => Promise<void>;
        /**
          * @default ""
         */
        "href": string;
        /**
          * @default ""
         */
        "imageUrl": string;
        "showComponent": () => Promise<void>;
        /**
          * @default true
         */
        "showLabel": boolean;
        /**
          * @default "_self"
         */
        "target": string;
        /**
          * @default ""
         */
        "userName": string;
    }
    interface IfxNotification {
        "icon": string;
        "linkHref": string;
        /**
          * @default "_blank"
         */
        "linkTarget": string;
        "linkText": string;
        /**
          * @default "success"
         */
        "variant": NotificationVariant;
    }
    interface IfxOverviewTable {
    }
    interface IfxPagination {
        /**
          * @default 1
         */
        "currentPage": number;
        "itemsPerPage": any[] | string;
        /**
          * @default true
         */
        "showItemsPerPage": boolean;
        /**
          * @default 1
         */
        "total": number;
    }
    interface IfxPopover {
        /**
          * Accessible label for the popover
          * @default null
         */
        "ariaLabel": string | null;
        /**
          * Whether the popover is disabled
          * @default false
         */
        "disabled": boolean;
        /**
          * Programmatically hide the popover
         */
        "hide": () => Promise<void>;
        /**
          * Whether the popover is initially open
          * @default false
         */
        "open": boolean;
        /**
          * Title text displayed in the popover header
          * @default ''
         */
        "popoverTitle": string;
        /**
          * Position of the popover relative to the trigger element
          * @default 'auto'
         */
        "position": 'bottom-start' | 'top-start' | 'left' | 'bottom-end' | 'top-end' | 'right' | 'bottom' | 'top' | 'auto';
        /**
          * Programmatically show the popover
         */
        "show": () => Promise<void>;
        /**
          * Body text displayed in the popover content
          * @default ''
         */
        "text": string;
        /**
          * Programmatically toggle the popover visibility
         */
        "toggle": () => Promise<void>;
    }
    interface IfxProgressBar {
        /**
          * @default false
         */
        "showLabel": boolean;
        "size": string;
        /**
          * @default 0
         */
        "value": number;
    }
    interface IfxRadioButton {
        "checked": boolean;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "error": boolean;
        "isChecked": () => Promise<boolean>;
        "name": string;
        /**
          * @default "s"
         */
        "size": "s" | "m";
        "value": string;
    }
    interface IfxRadioButtonGroup {
        /**
          * @default "vertical"
         */
        "alignment": "horizontal" | "vertical";
        "captionText": string;
        /**
          * @default "Group Label Text"
         */
        "groupLabelText": string;
        /**
          * @default false
         */
        "required": boolean;
        "setGroupError": (error: boolean) => Promise<void>;
        "showCaption": boolean;
        "showCaptionIcon": boolean;
        "showGroupLabel": boolean;
        "size": string;
    }
    interface IfxSearchBar {
        /**
          * @default "on"
         */
        "autocomplete": string;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default true
         */
        "isOpen": boolean;
        "maxlength"?: number;
        "onNavbarMobile": () => Promise<void>;
        "value": string;
    }
    interface IfxSearchField {
        "ariaDescribedBy"?: string | null;
        /**
          * @default "Search Field"
         */
        "ariaLabel": string | null;
        "ariaLabelledBy"?: string | null;
        /**
          * @default "off"
         */
        "autocomplete": string;
        /**
          * Public method to clear search history. This will clear the history from both localStorage and the internal state, and also reset any dropdown-related states.
         */
        "clearSearchHistory": () => Promise<void>;
        /**
          * @default "Clear search"
         */
        "deleteIconAriaLabel": string;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default "Search suggestions and history"
         */
        "dropdownAriaLabel": string;
        /**
          * @default true
         */
        "enableHistory": boolean;
        /**
          * @default "Remove from history"
         */
        "historyDeleteAriaLabel": string;
        /**
          * @default "Recent Searches"
         */
        "historyHeaderText": string;
        /**
          * @default "Search history item"
         */
        "historyItemAriaLabel": string;
        /**
          * @default "ifx-search-history"
         */
        "historyKey": string;
        /**
          * @default 5
         */
        "maxHistoryItems": number;
        /**
          * @default 10
         */
        "maxSuggestions": number;
        /**
          * @default null
         */
        "maxlength"?: number;
        /**
          * @default "Search..."
         */
        "placeholder": string;
        /**
          * @default false
         */
        "showDeleteIcon": boolean;
        /**
          * @default false
         */
        "showSuggestions": boolean;
        /**
          * @default "l"
         */
        "size": string;
        /**
          * @default "Search suggestion"
         */
        "suggestionAriaLabel": string;
        /**
          * @default []
         */
        "suggestions": SuggestionItem[];
        /**
          * @default ""
         */
        "value": string;
    }
    interface IfxSegment {
        "icon": string;
        "segmentIndex": number;
        /**
          * @default false
         */
        "selected": boolean;
        "value": string;
    }
    interface IfxSegmentedControl {
        /**
          * @default ""
         */
        "caption": string;
        /**
          * @default false
         */
        "error": boolean;
        /**
          * @default ""
         */
        "label": string;
        /**
          * @default false
         */
        "required": boolean;
        /**
          * @default "regular"
         */
        "size": "regular" | "small";
    }
    interface IfxSelect {
        "addItemFilter": string | RegExp | ItemFilterFn;
        "addItemText": string | AddItemTextFn;
        "addItems": boolean;
        "ajax": (fn: AjaxFn) => Promise<this>;
        "appendValue": string;
        "callbackOnCreateTemplates": OnCreateTemplates;
        "callbackOnInit": OnInit;
        /**
          * @default ''
         */
        "caption": string;
        /**
          * @default undefined
         */
        "choices": Array<any> | string;
        "classNames": ClassNames;
        "clearChoices": () => Promise<this>;
        "clearInput": () => Promise<this>;
        "clearSelection": () => Promise<void>;
        "clearStore": () => Promise<this>;
        "customAddItemText": CustomAddItemText;
        "delimiter": string;
        /**
          * @default false
         */
        "disabled": boolean;
        "duplicateItemsAllowed": boolean;
        "editItems": boolean;
        /**
          * @default false
         */
        "error": boolean;
        "fuseOptions": FuseOptions;
        "getValue": (valueOnly?: boolean) => Promise<string | Array<string>>;
        "handleChange": () => Promise<void>;
        "handleDeleteIcon": () => Promise<void>;
        "hideDropdown": (blurInput?: boolean) => Promise<this>;
        "highlightAll": () => Promise<this>;
        "highlightItem": (item: HTMLElement, runEvent?: boolean) => Promise<this>;
        "itemSelectText": '';
        "items": Array<any>;
        /**
          * @default ''
         */
        "label": string;
        "loadingText": string;
        "maxItemCount": number;
        "maxItemText": string | MaxItemTextFn;
        "name": string;
        "noChoicesText": string | NoChoicesTextFn;
        "noResultsText": string | NoResultsTextFn;
        "options": any[] | string;
        "paste": boolean;
        "placeholder": boolean | string;
        /**
          * @default 'Placeholder'
         */
        "placeholderValue": string;
        "position": 'auto' | 'top' | 'bottom';
        "prependValue": string;
        "removeActiveItems": (excludedId?: number) => Promise<this>;
        "removeActiveItemsByValue": (value: string) => Promise<this>;
        "removeHighlightedItems": (runEvent?: boolean) => Promise<this>;
        "removeItemButton": boolean;
        "removeItems": boolean;
        "renderChoiceLimit": number;
        "renderSelectedChoices": 'always' | 'auto';
        /**
          * @default false
         */
        "required": boolean;
        "resetScrollPosition": boolean;
        "searchChoices": boolean;
        "searchFields": Array<string> | string;
        "searchFloor": number;
        "searchPlaceholderValue": string;
        "searchResultLimit": number;
        "setChoiceByValue": (value: string | Array<string>) => Promise<this>;
        "setChoices": (choices: any[] | string, value: string, label: string, replaceChoices?: boolean) => Promise<this>;
        "setValue": (args: Array<any>) => Promise<this>;
        "shouldSort": boolean;
        "shouldSortItems": boolean;
        /**
          * @default true
         */
        "showClearButton": boolean;
        "showDropdown": (focusInput?: boolean) => Promise<this>;
        "showSearch": boolean;
        /**
          * @default 'medium (40px)'
         */
        "size": string;
        "sorter": SortFn;
        "unhighlightAll": () => Promise<this>;
        "unhighlightItem": (item: HTMLElement) => Promise<this>;
        "uniqueItemText": UniqueItemText;
        "value": string;
        "valueComparer": ValueCompareFunction;
    }
    interface IfxSetFilter {
        "filterLabel": string;
        "filterName": string;
        "options": any[] | string;
        "placeholder": string;
        /**
          * @default "text"
         */
        "type": "text" | "single-select" | "multi-select";
    }
    interface IfxSidebar {
        /**
          * @default ""
         */
        "applicationName": string;
        "collapse": () => Promise<void>;
        /**
          * @default false
         */
        "collapsed": boolean;
        /**
          * @default false
         */
        "collapsible": boolean;
        /**
          * @default "© 1999 - " + this.currentYear + " Infineon Technologies AG"
         */
        "copyrightText": string;
        "expand": () => Promise<void>;
        /**
          * @default "Hide Menu"
         */
        "hideMenuLabel": string;
        /**
          * @default "#"
         */
        "imprint": string;
        /**
          * @default true
         */
        "initialCollapse": boolean;
        /**
          * @default "#"
         */
        "privacyPolicy": string;
        /**
          * @default true
         */
        "showFooter": boolean;
        /**
          * @default true
         */
        "showHeader": boolean;
        /**
          * @default "_blank"
         */
        "target": string;
        /**
          * @default "#"
         */
        "termsOfUse": string;
        "toggleCollapse": () => Promise<void>;
    }
    interface IfxSidebarItem {
        /**
          * @default false
         */
        "active": boolean;
        "expandMenu": (ac: boolean) => Promise<void>;
        "handleItemClick": (item: HTMLElement) => void;
        /**
          * @default ""
         */
        "href": string;
        /**
          * @default ""
         */
        "icon": string;
        /**
          * @default false
         */
        "isActionItem": boolean;
        "isItemExpandable": () => Promise<boolean>;
        "numberIndicator": number;
        "setActiveClasses": () => Promise<void>;
        /**
          * @default "_self"
         */
        "target": string;
    }
    interface IfxSidebarTitle {
        /**
          * @default false
         */
        "showInCollapsed": boolean;
    }
    interface IfxSlider {
        "ariaLabel": string | null;
        /**
          * @default false
         */
        "disabled": boolean;
        "leftIcon": string;
        "leftText": string;
        /**
          * @default 100
         */
        "max": number;
        "maxValueHandle": number;
        /**
          * @default 0
         */
        "min": number;
        "minValueHandle": number;
        "rightIcon": string;
        "rightText": string;
        /**
          * @default false
         */
        "showPercentage": boolean;
        /**
          * @default 1
         */
        "step": number;
        /**
          * @default "single"
         */
        "type": "single" | "double";
        "value": number;
    }
    interface IfxSpinner {
        "ariaLabel": string | null;
        /**
          * @default false
         */
        "inverted": boolean;
        "size": string;
        "variant": string;
    }
    interface IfxStatus {
        /**
          * @default false
         */
        "border": boolean;
        /**
          * @default "orange-500"
         */
        "color": string;
        "label": string;
    }
    interface IfxStep {
        /**
          * @default false
         */
        "complete"?: boolean;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        /**
          * @default false
         */
        "lastStep": boolean;
        /**
          * @default 1
         */
        "stepId": number;
        /**
          * @default { 		activeStep: 1, 		showStepNumber: false, 		variant: "default", 		indicatorPosition: "left", 	}
         */
        "stepperState": StepperState;
    }
    interface IfxStepper {
        /**
          * @default 1
         */
        "activeStep": number;
        "ariaCurrent": string | null;
        "ariaLabel": string | null;
        /**
          * @default "left"
         */
        "indicatorPosition"?: "left" | "right";
        /**
          * @default false
         */
        "showStepNumber"?: boolean;
        /**
          * @default "default"
         */
        "variant"?: "default" | "compact" | "vertical";
    }
    /**
     * A toggle switch component for binary on/off states.
     * This component is form-associated, meaning it can participate in HTML forms
     * just like native form controls. It supports form validation, form reset,
     * and browser autofill/restore functionality.
     * Code organization follows the Stencil Style Guide:
     * https://stenciljs.com/docs/style-guide
     * 1. Own Properties (internal, not exposed)
     * 2.
     * @Element (reference to host)
     * 3.
     * @State (internal reactive state)
     * 4.
     * @Prop (public API properties)
     * 5.
     * @Event (emitted events)
     * 6. Lifecycle methods
     * 7.
     * @Listen decorators
     * 8.
     * @Method (public methods)
     * 9. Private methods
     * 10. render()
     * Framework Integration:
     * - Vue: Supports v-model binding on the 'checked' property
     * - Angular: Supports [(ngModel)] and reactive forms (formControl)
     * - React: Standard prop binding and event handling
     * Configuration in stencil.config.ts enables framework-specific bindings.
     */
    interface IfxSwitch {
        /**
          * Sets the checked state of the switch.
          * @default false
         */
        "checked": boolean;
        /**
          * Disables user interaction when true.
          * @default false
         */
        "disabled": boolean;
        /**
          * Returns the current checked state.
         */
        "isChecked": () => Promise<boolean>;
        /**
          * Form field name.
          * @default ""
         */
        "name": string;
        /**
          * Sets the checked state.
          * @param checked - New checked state.
         */
        "setChecked": (checked: boolean) => Promise<void>;
        /**
          * Toggles the checked state.
          * @returns Resolves when the toggle is complete.
         */
        "toggle": () => Promise<boolean>;
        /**
          * Form field value when checked. If not set, defaults to "on" (standard checkbox behavior).
          * @default "on"
         */
        "value": string;
    }
    interface IfxTab {
        "disabled": boolean;
        "header": string;
        /**
          * @default ""
         */
        "icon": string;
        /**
          * @default "left"
         */
        "iconPosition": "left" | "right";
    }
    interface IfxTable {
        /**
          * Options for button renderer including click handler.
         */
        "buttonRendererOptions"?: {
		onButtonClick?: (params: any, event: Event) => void;
	};
        /**
          * Options for checkbox renderer including click handler.
         */
        "checkboxRendererOptions"?: {
		onCheckboxClick?: (params: any, event: Event) => void;
	};
        /**
          * The column definitions for the grid.
         */
        "cols": any;
        /**
          * Minimum width for columns.
         */
        "columnMinWidth"?: number;
        /**
          * Fixed width for columns.
         */
        "columnWidth"?: string;
        /**
          * Enable row selection.
          * @default false
         */
        "enableSelection": boolean;
        /**
          * Filter display orientation (sidebar or inline).
          * @default "sidebar"
         */
        "filterOrientation": string;
        /**
          * Auto-fit columns to container width.
          * @default false
         */
        "fitColumns": boolean;
        /**
          * Headline text displayed above the grid.
          * @default ""
         */
        "headline": string;
        /**
          * Numeric value displayed in headline.
          * @default null
         */
        "headlineNumber": number;
        /**
          * Options for icon button renderer including click handler.
         */
        "iconButtonRendererOptions"?: {
		onIconButtonClick?: (params: any, event: Event) => void;
	};
        /**
          * Shows the loading overlay on the grid.
          * @returns
         */
        "onBtShowLoading": () => Promise<void>;
        /**
          * Enable or disable pagination.
          * @default true
         */
        "pagination": boolean;
        /**
          * Number of items per page.
         */
        "paginationItemsPerPage": string;
        /**
          * Height of each row.
          * @default "default"
         */
        "rowHeight": string;
        /**
          * The rows definitions for the grid.
         */
        "rows": any;
        /**
          * Handler for server-side page changes.
         */
        "serverPageChangeHandler"?: (params: {
		page: number;
		pageSize: number;
	}) => Promise<{ rows: any[]; total: number }>;
        /**
          * Enable server-side pagination mode.
          * @default false
         */
        "serverSidePagination": boolean;
        /**
          * Show loading overlay.
          * @default false
         */
        "showLoading": boolean;
        /**
          * Total height of the table.
          * @default "auto"
         */
        "tableHeight": string;
        /**
          * Visual variant of the grid.
          * @default "default"
         */
        "variant": string;
    }
    interface IfxTabs {
        /**
          * @default 0
         */
        "activeTabIndex": number;
        /**
          * @default false
         */
        "fullWidth": boolean;
        /**
          * @default "horizontal"
         */
        "orientation": string;
    }
    interface IfxTemplate {
        "name": string;
        "thumbnail": string;
        "toggleTemplate": (currTemp: any) => Promise<void>;
    }
    interface IfxTemplatesUi {
    }
    interface IfxTextField {
        /**
          * @default "on"
         */
        "autocomplete": string;
        /**
          * @default ""
         */
        "caption": string;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "error": boolean;
        /**
          * @default ""
         */
        "icon": string;
        /**
          * @default "text-field"
         */
        "internalId": string;
        /**
          * @default ""
         */
        "label": string;
        "maxlength"?: number;
        /**
          * @default "Placeholder"
         */
        "placeholder": string;
        /**
          * @default false
         */
        "readOnly": boolean;
        /**
          * @default false
         */
        "required": boolean;
        "reset": () => Promise<void>;
        /**
          * @default false
         */
        "showDeleteIcon": boolean;
        /**
          * @default "m"
         */
        "size": string;
        /**
          * @default false
         */
        "success": boolean;
        /**
          * @default "text"
         */
        "type": "text" | "password";
        /**
          * @default ""
         */
        "value": string;
    }
    interface IfxTextarea {
        "caption": string;
        "cols": number;
        /**
          * @default false
         */
        "disabled": boolean;
        /**
          * @default false
         */
        "error": boolean;
        /**
          * @default "false"
         */
        "fullWidth": string;
        "label": string;
        "maxlength": number;
        "name": string;
        "placeholder": string;
        /**
          * @default false
         */
        "readOnly": boolean;
        /**
          * @default false
         */
        "required": boolean;
        "reset": () => Promise<void>;
        /**
          * @default "both"
         */
        "resize": "both" | "horizontal" | "vertical" | "none";
        "rows": number;
        "value": string;
        /**
          * @default "soft"
         */
        "wrap": "hard" | "soft" | "off";
    }
    interface IfxTooltip {
        /**
          * @default false
         */
        "appendToBody": boolean;
        "ariaLabel": string | null;
        /**
          * @default ''
         */
        "header": string;
        "icon": string;
        /**
          * @default 'auto'
         */
        "position": 'bottom-start' | 'top-start' | 'left' | 'bottom-end' | 'top-end' | 'right' | 'bottom' | 'top' | 'auto';
        /**
          * @default ''
         */
        "text": string;
        /**
          * @default 'compact'
         */
        "variant": 'compact' | 'dismissible' | 'extended';
    }
    interface IfxTreeView {
        "ariaLabel": string | null;
        /**
          * @default false
         */
        "disableAllItems": boolean;
        /**
          * @default false
         */
        "expandAllItems": boolean;
        "label"?: string;
    }
    interface IfxTreeViewItem {
        "ariaLabel": string | null;
        /**
          * @default false
         */
        "disableItem": boolean;
        /**
          * @default false
         */
        "expanded": boolean;
        /**
          * @default false
         */
        "initiallyExpanded": boolean;
        /**
          * @default false
         */
        "initiallySelected": boolean;
        "value": string;
    }
}
export interface IfxAccordionItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxAccordionItemElement;
}
export interface IfxActionListItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxActionListItemElement;
}
export interface IfxAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxAlertElement;
}
export interface IfxBreadcrumbItemLabelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxBreadcrumbItemLabelElement;
}
export interface IfxCardImageCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxCardImageElement;
}
export interface IfxCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxCheckboxElement;
}
export interface IfxChipCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxChipElement;
}
export interface IfxChipItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxChipItemElement;
}
export interface IfxContentSwitcherCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxContentSwitcherElement;
}
export interface IfxDatePickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxDatePickerElement;
}
export interface IfxDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxDropdownElement;
}
export interface IfxDropdownItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxDropdownItemElement;
}
export interface IfxDropdownMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxDropdownMenuElement;
}
export interface IfxFileUploadCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxFileUploadElement;
}
export interface IfxFilterAccordionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxFilterAccordionElement;
}
export interface IfxFilterBarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxFilterBarElement;
}
export interface IfxFilterSearchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxFilterSearchElement;
}
export interface IfxFilterTypeGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxFilterTypeGroupElement;
}
export interface IfxIconCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxIconElement;
}
export interface IfxListCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxListElement;
}
export interface IfxListEntryCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxListEntryElement;
}
export interface IfxModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxModalElement;
}
export interface IfxMultiselectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxMultiselectElement;
}
export interface IfxNavbarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxNavbarElement;
}
export interface IfxNavbarItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxNavbarItemElement;
}
export interface IfxPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxPaginationElement;
}
export interface IfxPopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxPopoverElement;
}
export interface IfxRadioButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxRadioButtonElement;
}
export interface IfxSearchBarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxSearchBarElement;
}
export interface IfxSearchFieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxSearchFieldElement;
}
export interface IfxSegmentCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxSegmentElement;
}
export interface IfxSegmentedControlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxSegmentedControlElement;
}
export interface IfxSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxSelectElement;
}
export interface IfxSetFilterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxSetFilterElement;
}
export interface IfxSidebarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxSidebarElement;
}
export interface IfxSidebarItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxSidebarItemElement;
}
export interface IfxSliderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxSliderElement;
}
export interface IfxStepperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxStepperElement;
}
export interface IfxSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxSwitchElement;
}
export interface IfxTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxTabElement;
}
export interface IfxTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxTableElement;
}
export interface IfxTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxTabsElement;
}
export interface IfxTemplateCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxTemplateElement;
}
export interface IfxTextFieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxTextFieldElement;
}
export interface IfxTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxTextareaElement;
}
export interface IfxTreeViewCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxTreeViewElement;
}
export interface IfxTreeViewItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIfxTreeViewItemElement;
}
declare global {
    interface HTMLIfxAccordionElement extends Components.IfxAccordion, HTMLStencilElement {
    }
    var HTMLIfxAccordionElement: {
        prototype: HTMLIfxAccordionElement;
        new (): HTMLIfxAccordionElement;
    };
    interface HTMLIfxAccordionItemElementEventMap {
        "ifxOpen": any;
        "ifxClose": any;
    }
    interface HTMLIfxAccordionItemElement extends Components.IfxAccordionItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxAccordionItemElementEventMap>(type: K, listener: (this: HTMLIfxAccordionItemElement, ev: IfxAccordionItemCustomEvent<HTMLIfxAccordionItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxAccordionItemElementEventMap>(type: K, listener: (this: HTMLIfxAccordionItemElement, ev: IfxAccordionItemCustomEvent<HTMLIfxAccordionItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxAccordionItemElement: {
        prototype: HTMLIfxAccordionItemElement;
        new (): HTMLIfxAccordionItemElement;
    };
    interface HTMLIfxActionListElement extends Components.IfxActionList, HTMLStencilElement {
    }
    var HTMLIfxActionListElement: {
        prototype: HTMLIfxActionListElement;
        new (): HTMLIfxActionListElement;
    };
    interface HTMLIfxActionListItemElementEventMap {
        "ifxActionListItemClick": ActionListItemClickEvent;
    }
    interface HTMLIfxActionListItemElement extends Components.IfxActionListItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxActionListItemElementEventMap>(type: K, listener: (this: HTMLIfxActionListItemElement, ev: IfxActionListItemCustomEvent<HTMLIfxActionListItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxActionListItemElementEventMap>(type: K, listener: (this: HTMLIfxActionListItemElement, ev: IfxActionListItemCustomEvent<HTMLIfxActionListItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxActionListItemElement: {
        prototype: HTMLIfxActionListItemElement;
        new (): HTMLIfxActionListItemElement;
    };
    interface HTMLIfxAiLabelElement extends Components.IfxAiLabel, HTMLStencilElement {
    }
    var HTMLIfxAiLabelElement: {
        prototype: HTMLIfxAiLabelElement;
        new (): HTMLIfxAiLabelElement;
    };
    interface HTMLIfxAlertElementEventMap {
        "ifxClose": any;
    }
    interface HTMLIfxAlertElement extends Components.IfxAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxAlertElementEventMap>(type: K, listener: (this: HTMLIfxAlertElement, ev: IfxAlertCustomEvent<HTMLIfxAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxAlertElementEventMap>(type: K, listener: (this: HTMLIfxAlertElement, ev: IfxAlertCustomEvent<HTMLIfxAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxAlertElement: {
        prototype: HTMLIfxAlertElement;
        new (): HTMLIfxAlertElement;
    };
    interface HTMLIfxBasicTableElement extends Components.IfxBasicTable, HTMLStencilElement {
    }
    var HTMLIfxBasicTableElement: {
        prototype: HTMLIfxBasicTableElement;
        new (): HTMLIfxBasicTableElement;
    };
    interface HTMLIfxBreadcrumbElement extends Components.IfxBreadcrumb, HTMLStencilElement {
    }
    var HTMLIfxBreadcrumbElement: {
        prototype: HTMLIfxBreadcrumbElement;
        new (): HTMLIfxBreadcrumbElement;
    };
    interface HTMLIfxBreadcrumbItemElement extends Components.IfxBreadcrumbItem, HTMLStencilElement {
    }
    var HTMLIfxBreadcrumbItemElement: {
        prototype: HTMLIfxBreadcrumbItemElement;
        new (): HTMLIfxBreadcrumbItemElement;
    };
    interface HTMLIfxBreadcrumbItemLabelElementEventMap {
        "breadcrumbMenuIconWrapper": HTMLElement;
    }
    interface HTMLIfxBreadcrumbItemLabelElement extends Components.IfxBreadcrumbItemLabel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxBreadcrumbItemLabelElementEventMap>(type: K, listener: (this: HTMLIfxBreadcrumbItemLabelElement, ev: IfxBreadcrumbItemLabelCustomEvent<HTMLIfxBreadcrumbItemLabelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxBreadcrumbItemLabelElementEventMap>(type: K, listener: (this: HTMLIfxBreadcrumbItemLabelElement, ev: IfxBreadcrumbItemLabelCustomEvent<HTMLIfxBreadcrumbItemLabelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxBreadcrumbItemLabelElement: {
        prototype: HTMLIfxBreadcrumbItemLabelElement;
        new (): HTMLIfxBreadcrumbItemLabelElement;
    };
    interface HTMLIfxButtonElement extends Components.IfxButton, HTMLStencilElement {
    }
    var HTMLIfxButtonElement: {
        prototype: HTMLIfxButtonElement;
        new (): HTMLIfxButtonElement;
    };
    interface HTMLIfxCardElement extends Components.IfxCard, HTMLStencilElement {
    }
    var HTMLIfxCardElement: {
        prototype: HTMLIfxCardElement;
        new (): HTMLIfxCardElement;
    };
    interface HTMLIfxCardHeadlineElement extends Components.IfxCardHeadline, HTMLStencilElement {
    }
    var HTMLIfxCardHeadlineElement: {
        prototype: HTMLIfxCardHeadlineElement;
        new (): HTMLIfxCardHeadlineElement;
    };
    interface HTMLIfxCardImageElementEventMap {
        "imgPosition": any;
    }
    interface HTMLIfxCardImageElement extends Components.IfxCardImage, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxCardImageElementEventMap>(type: K, listener: (this: HTMLIfxCardImageElement, ev: IfxCardImageCustomEvent<HTMLIfxCardImageElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxCardImageElementEventMap>(type: K, listener: (this: HTMLIfxCardImageElement, ev: IfxCardImageCustomEvent<HTMLIfxCardImageElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxCardImageElement: {
        prototype: HTMLIfxCardImageElement;
        new (): HTMLIfxCardImageElement;
    };
    interface HTMLIfxCardLinksElement extends Components.IfxCardLinks, HTMLStencilElement {
    }
    var HTMLIfxCardLinksElement: {
        prototype: HTMLIfxCardLinksElement;
        new (): HTMLIfxCardLinksElement;
    };
    interface HTMLIfxCardOverlineElement extends Components.IfxCardOverline, HTMLStencilElement {
    }
    var HTMLIfxCardOverlineElement: {
        prototype: HTMLIfxCardOverlineElement;
        new (): HTMLIfxCardOverlineElement;
    };
    interface HTMLIfxCardTextElement extends Components.IfxCardText, HTMLStencilElement {
    }
    var HTMLIfxCardTextElement: {
        prototype: HTMLIfxCardTextElement;
        new (): HTMLIfxCardTextElement;
    };
    interface HTMLIfxCheckboxElementEventMap {
        "ifxChange": boolean;
        "ifxError": boolean;
    }
    interface HTMLIfxCheckboxElement extends Components.IfxCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxCheckboxElementEventMap>(type: K, listener: (this: HTMLIfxCheckboxElement, ev: IfxCheckboxCustomEvent<HTMLIfxCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxCheckboxElementEventMap>(type: K, listener: (this: HTMLIfxCheckboxElement, ev: IfxCheckboxCustomEvent<HTMLIfxCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxCheckboxElement: {
        prototype: HTMLIfxCheckboxElement;
        new (): HTMLIfxCheckboxElement;
    };
    interface HTMLIfxCheckboxGroupElement extends Components.IfxCheckboxGroup, HTMLStencilElement {
    }
    var HTMLIfxCheckboxGroupElement: {
        prototype: HTMLIfxCheckboxGroupElement;
        new (): HTMLIfxCheckboxGroupElement;
    };
    interface HTMLIfxChipElementEventMap {
        "ifxChange": {
		previousSelection: Array<ChipItemSelectEvent>;
		currentSelection: Array<ChipItemSelectEvent>;
		name: string;
	};
    }
    interface HTMLIfxChipElement extends Components.IfxChip, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxChipElementEventMap>(type: K, listener: (this: HTMLIfxChipElement, ev: IfxChipCustomEvent<HTMLIfxChipElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxChipElementEventMap>(type: K, listener: (this: HTMLIfxChipElement, ev: IfxChipCustomEvent<HTMLIfxChipElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxChipElement: {
        prototype: HTMLIfxChipElement;
        new (): HTMLIfxChipElement;
    };
    interface HTMLIfxChipItemElementEventMap {
        "ifxChipItemSelect": ChipItemSelectEvent;
    }
    interface HTMLIfxChipItemElement extends Components.IfxChipItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxChipItemElementEventMap>(type: K, listener: (this: HTMLIfxChipItemElement, ev: IfxChipItemCustomEvent<HTMLIfxChipItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxChipItemElementEventMap>(type: K, listener: (this: HTMLIfxChipItemElement, ev: IfxChipItemCustomEvent<HTMLIfxChipItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxChipItemElement: {
        prototype: HTMLIfxChipItemElement;
        new (): HTMLIfxChipItemElement;
    };
    interface HTMLIfxContentSwitcherElementEventMap {
        "ifxChange": ChangeEvent;
    }
    interface HTMLIfxContentSwitcherElement extends Components.IfxContentSwitcher, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxContentSwitcherElementEventMap>(type: K, listener: (this: HTMLIfxContentSwitcherElement, ev: IfxContentSwitcherCustomEvent<HTMLIfxContentSwitcherElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxContentSwitcherElementEventMap>(type: K, listener: (this: HTMLIfxContentSwitcherElement, ev: IfxContentSwitcherCustomEvent<HTMLIfxContentSwitcherElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxContentSwitcherElement: {
        prototype: HTMLIfxContentSwitcherElement;
        new (): HTMLIfxContentSwitcherElement;
    };
    interface HTMLIfxContentSwitcherItemElement extends Components.IfxContentSwitcherItem, HTMLStencilElement {
    }
    var HTMLIfxContentSwitcherItemElement: {
        prototype: HTMLIfxContentSwitcherItemElement;
        new (): HTMLIfxContentSwitcherItemElement;
    };
    interface HTMLIfxDatePickerElementEventMap {
        "ifxDate": any;
    }
    interface HTMLIfxDatePickerElement extends Components.IfxDatePicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxDatePickerElementEventMap>(type: K, listener: (this: HTMLIfxDatePickerElement, ev: IfxDatePickerCustomEvent<HTMLIfxDatePickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxDatePickerElementEventMap>(type: K, listener: (this: HTMLIfxDatePickerElement, ev: IfxDatePickerCustomEvent<HTMLIfxDatePickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxDatePickerElement: {
        prototype: HTMLIfxDatePickerElement;
        new (): HTMLIfxDatePickerElement;
    };
    interface HTMLIfxDownloadElement extends Components.IfxDownload, HTMLStencilElement {
    }
    var HTMLIfxDownloadElement: {
        prototype: HTMLIfxDownloadElement;
        new (): HTMLIfxDownloadElement;
    };
    interface HTMLIfxDropdownElementEventMap {
        "ifxOpen": any;
        "ifxClose": any;
        "ifxDropdown": any;
    }
    interface HTMLIfxDropdownElement extends Components.IfxDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxDropdownElementEventMap>(type: K, listener: (this: HTMLIfxDropdownElement, ev: IfxDropdownCustomEvent<HTMLIfxDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxDropdownElementEventMap>(type: K, listener: (this: HTMLIfxDropdownElement, ev: IfxDropdownCustomEvent<HTMLIfxDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxDropdownElement: {
        prototype: HTMLIfxDropdownElement;
        new (): HTMLIfxDropdownElement;
    };
    interface HTMLIfxDropdownHeaderElement extends Components.IfxDropdownHeader, HTMLStencilElement {
    }
    var HTMLIfxDropdownHeaderElement: {
        prototype: HTMLIfxDropdownHeaderElement;
        new (): HTMLIfxDropdownHeaderElement;
    };
    interface HTMLIfxDropdownItemElementEventMap {
        "ifxDropdownItem": any;
    }
    interface HTMLIfxDropdownItemElement extends Components.IfxDropdownItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxDropdownItemElementEventMap>(type: K, listener: (this: HTMLIfxDropdownItemElement, ev: IfxDropdownItemCustomEvent<HTMLIfxDropdownItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxDropdownItemElementEventMap>(type: K, listener: (this: HTMLIfxDropdownItemElement, ev: IfxDropdownItemCustomEvent<HTMLIfxDropdownItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxDropdownItemElement: {
        prototype: HTMLIfxDropdownItemElement;
        new (): HTMLIfxDropdownItemElement;
    };
    interface HTMLIfxDropdownMenuElementEventMap {
        "menuSize": any;
        "ifxDropdownMenuItem": CustomEvent;
    }
    interface HTMLIfxDropdownMenuElement extends Components.IfxDropdownMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxDropdownMenuElementEventMap>(type: K, listener: (this: HTMLIfxDropdownMenuElement, ev: IfxDropdownMenuCustomEvent<HTMLIfxDropdownMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxDropdownMenuElementEventMap>(type: K, listener: (this: HTMLIfxDropdownMenuElement, ev: IfxDropdownMenuCustomEvent<HTMLIfxDropdownMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxDropdownMenuElement: {
        prototype: HTMLIfxDropdownMenuElement;
        new (): HTMLIfxDropdownMenuElement;
    };
    interface HTMLIfxDropdownSeparatorElement extends Components.IfxDropdownSeparator, HTMLStencilElement {
    }
    var HTMLIfxDropdownSeparatorElement: {
        prototype: HTMLIfxDropdownSeparatorElement;
        new (): HTMLIfxDropdownSeparatorElement;
    };
    interface HTMLIfxDropdownTriggerElement extends Components.IfxDropdownTrigger, HTMLStencilElement {
    }
    var HTMLIfxDropdownTriggerElement: {
        prototype: HTMLIfxDropdownTriggerElement;
        new (): HTMLIfxDropdownTriggerElement;
    };
    interface HTMLIfxDropdownTriggerButtonElement extends Components.IfxDropdownTriggerButton, HTMLStencilElement {
    }
    var HTMLIfxDropdownTriggerButtonElement: {
        prototype: HTMLIfxDropdownTriggerButtonElement;
        new (): HTMLIfxDropdownTriggerButtonElement;
    };
    interface HTMLIfxFaqElement extends Components.IfxFaq, HTMLStencilElement {
    }
    var HTMLIfxFaqElement: {
        prototype: HTMLIfxFaqElement;
        new (): HTMLIfxFaqElement;
    };
    interface HTMLIfxFileUploadElementEventMap {
        "ifxFileUploadAdd": {
		addedFiles: File[];
		files: File[];
	};
        "ifxFileUploadRemove": {
		removedFile: File;
		files: File[];
	};
        "ifxFileUploadChange": { files: File[] };
        "ifxFileUploadError": {
		errorType: string;
		file: File;
		message: string;
		reason?: string;
	};
        "ifxFileUploadInvalid": { file: File; reason: string };
        "ifxFileUploadStart": { file: File };
        "ifxFileUploadComplete": { file: File };
        "ifxFileUploadAllComplete": { files: File[] };
        "ifxFileUploadAbort": { file: File };
        "ifxFileUploadDrop": {
		droppedFiles: File[];
		acceptedFiles: File[];
		rejectedFiles: File[];
	};
        "ifxFileUploadClick": void;
        "ifxFileUploadMaxFilesExceeded": {
		maxFiles: number;
		attempted: number;
	};
        "ifxFileUploadValidation": { valid: boolean };
        "ifxFileUploadRetry": { file: File };
    }
    interface HTMLIfxFileUploadElement extends Components.IfxFileUpload, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxFileUploadElementEventMap>(type: K, listener: (this: HTMLIfxFileUploadElement, ev: IfxFileUploadCustomEvent<HTMLIfxFileUploadElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxFileUploadElementEventMap>(type: K, listener: (this: HTMLIfxFileUploadElement, ev: IfxFileUploadCustomEvent<HTMLIfxFileUploadElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxFileUploadElement: {
        prototype: HTMLIfxFileUploadElement;
        new (): HTMLIfxFileUploadElement;
    };
    interface HTMLIfxFilterAccordionElementEventMap {
        "ifxFilterAccordionChange": any;
    }
    interface HTMLIfxFilterAccordionElement extends Components.IfxFilterAccordion, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxFilterAccordionElementEventMap>(type: K, listener: (this: HTMLIfxFilterAccordionElement, ev: IfxFilterAccordionCustomEvent<HTMLIfxFilterAccordionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxFilterAccordionElementEventMap>(type: K, listener: (this: HTMLIfxFilterAccordionElement, ev: IfxFilterAccordionCustomEvent<HTMLIfxFilterAccordionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxFilterAccordionElement: {
        prototype: HTMLIfxFilterAccordionElement;
        new (): HTMLIfxFilterAccordionElement;
    };
    interface HTMLIfxFilterBarElementEventMap {
        "ifxTopbarFilterChange": any;
    }
    interface HTMLIfxFilterBarElement extends Components.IfxFilterBar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxFilterBarElementEventMap>(type: K, listener: (this: HTMLIfxFilterBarElement, ev: IfxFilterBarCustomEvent<HTMLIfxFilterBarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxFilterBarElementEventMap>(type: K, listener: (this: HTMLIfxFilterBarElement, ev: IfxFilterBarCustomEvent<HTMLIfxFilterBarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxFilterBarElement: {
        prototype: HTMLIfxFilterBarElement;
        new (): HTMLIfxFilterBarElement;
    };
    interface HTMLIfxFilterSearchElementEventMap {
        "ifxFilterSearchChange": any;
    }
    interface HTMLIfxFilterSearchElement extends Components.IfxFilterSearch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxFilterSearchElementEventMap>(type: K, listener: (this: HTMLIfxFilterSearchElement, ev: IfxFilterSearchCustomEvent<HTMLIfxFilterSearchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxFilterSearchElementEventMap>(type: K, listener: (this: HTMLIfxFilterSearchElement, ev: IfxFilterSearchCustomEvent<HTMLIfxFilterSearchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxFilterSearchElement: {
        prototype: HTMLIfxFilterSearchElement;
        new (): HTMLIfxFilterSearchElement;
    };
    interface HTMLIfxFilterTypeGroupElementEventMap {
        "ifxSidebarFilterChange": any;
    }
    interface HTMLIfxFilterTypeGroupElement extends Components.IfxFilterTypeGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxFilterTypeGroupElementEventMap>(type: K, listener: (this: HTMLIfxFilterTypeGroupElement, ev: IfxFilterTypeGroupCustomEvent<HTMLIfxFilterTypeGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxFilterTypeGroupElementEventMap>(type: K, listener: (this: HTMLIfxFilterTypeGroupElement, ev: IfxFilterTypeGroupCustomEvent<HTMLIfxFilterTypeGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxFilterTypeGroupElement: {
        prototype: HTMLIfxFilterTypeGroupElement;
        new (): HTMLIfxFilterTypeGroupElement;
    };
    interface HTMLIfxFooterElement extends Components.IfxFooter, HTMLStencilElement {
    }
    var HTMLIfxFooterElement: {
        prototype: HTMLIfxFooterElement;
        new (): HTMLIfxFooterElement;
    };
    interface HTMLIfxFooterColumnElement extends Components.IfxFooterColumn, HTMLStencilElement {
    }
    var HTMLIfxFooterColumnElement: {
        prototype: HTMLIfxFooterColumnElement;
        new (): HTMLIfxFooterColumnElement;
    };
    interface HTMLIfxIconElementEventMap {
        "consoleError": boolean;
    }
    interface HTMLIfxIconElement extends Components.IfxIcon, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxIconElementEventMap>(type: K, listener: (this: HTMLIfxIconElement, ev: IfxIconCustomEvent<HTMLIfxIconElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxIconElementEventMap>(type: K, listener: (this: HTMLIfxIconElement, ev: IfxIconCustomEvent<HTMLIfxIconElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxIconElement: {
        prototype: HTMLIfxIconElement;
        new (): HTMLIfxIconElement;
    };
    interface HTMLIfxIconButtonElement extends Components.IfxIconButton, HTMLStencilElement {
    }
    var HTMLIfxIconButtonElement: {
        prototype: HTMLIfxIconButtonElement;
        new (): HTMLIfxIconButtonElement;
    };
    interface HTMLIfxIconsPreviewElement extends Components.IfxIconsPreview, HTMLStencilElement {
    }
    var HTMLIfxIconsPreviewElement: {
        prototype: HTMLIfxIconsPreviewElement;
        new (): HTMLIfxIconsPreviewElement;
    };
    interface HTMLIfxIndicatorElement extends Components.IfxIndicator, HTMLStencilElement {
    }
    var HTMLIfxIndicatorElement: {
        prototype: HTMLIfxIndicatorElement;
        new (): HTMLIfxIndicatorElement;
    };
    interface HTMLIfxLinkElement extends Components.IfxLink, HTMLStencilElement {
    }
    var HTMLIfxLinkElement: {
        prototype: HTMLIfxLinkElement;
        new (): HTMLIfxLinkElement;
    };
    interface HTMLIfxListElementEventMap {
        "ifxListUpdate": any;
    }
    interface HTMLIfxListElement extends Components.IfxList, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxListElementEventMap>(type: K, listener: (this: HTMLIfxListElement, ev: IfxListCustomEvent<HTMLIfxListElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxListElementEventMap>(type: K, listener: (this: HTMLIfxListElement, ev: IfxListCustomEvent<HTMLIfxListElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxListElement: {
        prototype: HTMLIfxListElement;
        new (): HTMLIfxListElement;
    };
    interface HTMLIfxListEntryElementEventMap {
        "ifxListEntryChange": any;
    }
    interface HTMLIfxListEntryElement extends Components.IfxListEntry, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxListEntryElementEventMap>(type: K, listener: (this: HTMLIfxListEntryElement, ev: IfxListEntryCustomEvent<HTMLIfxListEntryElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxListEntryElementEventMap>(type: K, listener: (this: HTMLIfxListEntryElement, ev: IfxListEntryCustomEvent<HTMLIfxListEntryElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxListEntryElement: {
        prototype: HTMLIfxListEntryElement;
        new (): HTMLIfxListEntryElement;
    };
    interface HTMLIfxModalElementEventMap {
        "ifxOpen": any;
        "ifxClose": any;
    }
    interface HTMLIfxModalElement extends Components.IfxModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxModalElementEventMap>(type: K, listener: (this: HTMLIfxModalElement, ev: IfxModalCustomEvent<HTMLIfxModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxModalElementEventMap>(type: K, listener: (this: HTMLIfxModalElement, ev: IfxModalCustomEvent<HTMLIfxModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxModalElement: {
        prototype: HTMLIfxModalElement;
        new (): HTMLIfxModalElement;
    };
    interface HTMLIfxMultiselectElementEventMap {
        "ifxSelect": any;
        "ifxOpen": any;
    }
    interface HTMLIfxMultiselectElement extends Components.IfxMultiselect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxMultiselectElementEventMap>(type: K, listener: (this: HTMLIfxMultiselectElement, ev: IfxMultiselectCustomEvent<HTMLIfxMultiselectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxMultiselectElementEventMap>(type: K, listener: (this: HTMLIfxMultiselectElement, ev: IfxMultiselectCustomEvent<HTMLIfxMultiselectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxMultiselectElement: {
        prototype: HTMLIfxMultiselectElement;
        new (): HTMLIfxMultiselectElement;
    };
    interface HTMLIfxMultiselectOptionElement extends Components.IfxMultiselectOption, HTMLStencilElement {
    }
    var HTMLIfxMultiselectOptionElement: {
        prototype: HTMLIfxMultiselectOptionElement;
        new (): HTMLIfxMultiselectOptionElement;
    };
    interface HTMLIfxNavbarElementEventMap {
        "ifxNavbarMobileMenuIsOpen": any;
    }
    interface HTMLIfxNavbarElement extends Components.IfxNavbar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxNavbarElementEventMap>(type: K, listener: (this: HTMLIfxNavbarElement, ev: IfxNavbarCustomEvent<HTMLIfxNavbarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxNavbarElementEventMap>(type: K, listener: (this: HTMLIfxNavbarElement, ev: IfxNavbarCustomEvent<HTMLIfxNavbarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxNavbarElement: {
        prototype: HTMLIfxNavbarElement;
        new (): HTMLIfxNavbarElement;
    };
    interface HTMLIfxNavbarItemElementEventMap {
        "ifxNavItem": any;
    }
    interface HTMLIfxNavbarItemElement extends Components.IfxNavbarItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxNavbarItemElementEventMap>(type: K, listener: (this: HTMLIfxNavbarItemElement, ev: IfxNavbarItemCustomEvent<HTMLIfxNavbarItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxNavbarItemElementEventMap>(type: K, listener: (this: HTMLIfxNavbarItemElement, ev: IfxNavbarItemCustomEvent<HTMLIfxNavbarItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxNavbarItemElement: {
        prototype: HTMLIfxNavbarItemElement;
        new (): HTMLIfxNavbarItemElement;
    };
    interface HTMLIfxNavbarProfileElement extends Components.IfxNavbarProfile, HTMLStencilElement {
    }
    var HTMLIfxNavbarProfileElement: {
        prototype: HTMLIfxNavbarProfileElement;
        new (): HTMLIfxNavbarProfileElement;
    };
    interface HTMLIfxNotificationElement extends Components.IfxNotification, HTMLStencilElement {
    }
    var HTMLIfxNotificationElement: {
        prototype: HTMLIfxNotificationElement;
        new (): HTMLIfxNotificationElement;
    };
    interface HTMLIfxOverviewTableElement extends Components.IfxOverviewTable, HTMLStencilElement {
    }
    var HTMLIfxOverviewTableElement: {
        prototype: HTMLIfxOverviewTableElement;
        new (): HTMLIfxOverviewTableElement;
    };
    interface HTMLIfxPaginationElementEventMap {
        "ifxPageChange": any;
        "ifxItemsPerPageChange": any;
    }
    interface HTMLIfxPaginationElement extends Components.IfxPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxPaginationElementEventMap>(type: K, listener: (this: HTMLIfxPaginationElement, ev: IfxPaginationCustomEvent<HTMLIfxPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxPaginationElementEventMap>(type: K, listener: (this: HTMLIfxPaginationElement, ev: IfxPaginationCustomEvent<HTMLIfxPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxPaginationElement: {
        prototype: HTMLIfxPaginationElement;
        new (): HTMLIfxPaginationElement;
    };
    interface HTMLIfxPopoverElementEventMap {
        "ifxOpen": { trigger: HTMLElement | null };
        "ifxClose": any;
    }
    interface HTMLIfxPopoverElement extends Components.IfxPopover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxPopoverElementEventMap>(type: K, listener: (this: HTMLIfxPopoverElement, ev: IfxPopoverCustomEvent<HTMLIfxPopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxPopoverElementEventMap>(type: K, listener: (this: HTMLIfxPopoverElement, ev: IfxPopoverCustomEvent<HTMLIfxPopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxPopoverElement: {
        prototype: HTMLIfxPopoverElement;
        new (): HTMLIfxPopoverElement;
    };
    interface HTMLIfxProgressBarElement extends Components.IfxProgressBar, HTMLStencilElement {
    }
    var HTMLIfxProgressBarElement: {
        prototype: HTMLIfxProgressBarElement;
        new (): HTMLIfxProgressBarElement;
    };
    interface HTMLIfxRadioButtonElementEventMap {
        "ifxChange": any;
        "ifxError": any;
    }
    interface HTMLIfxRadioButtonElement extends Components.IfxRadioButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxRadioButtonElementEventMap>(type: K, listener: (this: HTMLIfxRadioButtonElement, ev: IfxRadioButtonCustomEvent<HTMLIfxRadioButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxRadioButtonElementEventMap>(type: K, listener: (this: HTMLIfxRadioButtonElement, ev: IfxRadioButtonCustomEvent<HTMLIfxRadioButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxRadioButtonElement: {
        prototype: HTMLIfxRadioButtonElement;
        new (): HTMLIfxRadioButtonElement;
    };
    interface HTMLIfxRadioButtonGroupElement extends Components.IfxRadioButtonGroup, HTMLStencilElement {
    }
    var HTMLIfxRadioButtonGroupElement: {
        prototype: HTMLIfxRadioButtonGroupElement;
        new (): HTMLIfxRadioButtonGroupElement;
    };
    interface HTMLIfxSearchBarElementEventMap {
        "ifxInput": any;
        "ifxOpen": any;
    }
    interface HTMLIfxSearchBarElement extends Components.IfxSearchBar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxSearchBarElementEventMap>(type: K, listener: (this: HTMLIfxSearchBarElement, ev: IfxSearchBarCustomEvent<HTMLIfxSearchBarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxSearchBarElementEventMap>(type: K, listener: (this: HTMLIfxSearchBarElement, ev: IfxSearchBarCustomEvent<HTMLIfxSearchBarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxSearchBarElement: {
        prototype: HTMLIfxSearchBarElement;
        new (): HTMLIfxSearchBarElement;
    };
    interface HTMLIfxSearchFieldElementEventMap {
        "ifxInput": string;
        "ifxSuggestionRequested": string;
        "ifxSuggestionSelected": SuggestionItem;
        "ifxFocus": void;
        "ifxBlur": void;
    }
    interface HTMLIfxSearchFieldElement extends Components.IfxSearchField, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxSearchFieldElementEventMap>(type: K, listener: (this: HTMLIfxSearchFieldElement, ev: IfxSearchFieldCustomEvent<HTMLIfxSearchFieldElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxSearchFieldElementEventMap>(type: K, listener: (this: HTMLIfxSearchFieldElement, ev: IfxSearchFieldCustomEvent<HTMLIfxSearchFieldElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxSearchFieldElement: {
        prototype: HTMLIfxSearchFieldElement;
        new (): HTMLIfxSearchFieldElement;
    };
    interface HTMLIfxSegmentElementEventMap {
        "segmentSelect": number;
    }
    interface HTMLIfxSegmentElement extends Components.IfxSegment, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxSegmentElementEventMap>(type: K, listener: (this: HTMLIfxSegmentElement, ev: IfxSegmentCustomEvent<HTMLIfxSegmentElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxSegmentElementEventMap>(type: K, listener: (this: HTMLIfxSegmentElement, ev: IfxSegmentCustomEvent<HTMLIfxSegmentElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxSegmentElement: {
        prototype: HTMLIfxSegmentElement;
        new (): HTMLIfxSegmentElement;
    };
    interface HTMLIfxSegmentedControlElementEventMap {
        "ifxChange": {
		previousValue: string;
		selectedValue: string;
	};
    }
    interface HTMLIfxSegmentedControlElement extends Components.IfxSegmentedControl, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxSegmentedControlElementEventMap>(type: K, listener: (this: HTMLIfxSegmentedControlElement, ev: IfxSegmentedControlCustomEvent<HTMLIfxSegmentedControlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxSegmentedControlElementEventMap>(type: K, listener: (this: HTMLIfxSegmentedControlElement, ev: IfxSegmentedControlCustomEvent<HTMLIfxSegmentedControlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxSegmentedControlElement: {
        prototype: HTMLIfxSegmentedControlElement;
        new (): HTMLIfxSegmentedControlElement;
    };
    interface HTMLIfxSelectElementEventMap {
        "ifxSelect": CustomEvent;
        "ifxInput": CustomEvent;
    }
    interface HTMLIfxSelectElement extends Components.IfxSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxSelectElementEventMap>(type: K, listener: (this: HTMLIfxSelectElement, ev: IfxSelectCustomEvent<HTMLIfxSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxSelectElementEventMap>(type: K, listener: (this: HTMLIfxSelectElement, ev: IfxSelectCustomEvent<HTMLIfxSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxSelectElement: {
        prototype: HTMLIfxSelectElement;
        new (): HTMLIfxSelectElement;
    };
    interface HTMLIfxSetFilterElementEventMap {
        "ifxFilterSelect": any;
    }
    interface HTMLIfxSetFilterElement extends Components.IfxSetFilter, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxSetFilterElementEventMap>(type: K, listener: (this: HTMLIfxSetFilterElement, ev: IfxSetFilterCustomEvent<HTMLIfxSetFilterElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxSetFilterElementEventMap>(type: K, listener: (this: HTMLIfxSetFilterElement, ev: IfxSetFilterCustomEvent<HTMLIfxSetFilterElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxSetFilterElement: {
        prototype: HTMLIfxSetFilterElement;
        new (): HTMLIfxSetFilterElement;
    };
    interface HTMLIfxSidebarElementEventMap {
        "ifxSidebarCollapseChange": { collapsed: boolean };
    }
    interface HTMLIfxSidebarElement extends Components.IfxSidebar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxSidebarElementEventMap>(type: K, listener: (this: HTMLIfxSidebarElement, ev: IfxSidebarCustomEvent<HTMLIfxSidebarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxSidebarElementEventMap>(type: K, listener: (this: HTMLIfxSidebarElement, ev: IfxSidebarCustomEvent<HTMLIfxSidebarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxSidebarElement: {
        prototype: HTMLIfxSidebarElement;
        new (): HTMLIfxSidebarElement;
    };
    interface HTMLIfxSidebarItemElementEventMap {
        "ifxSidebarMenu": any;
        "ifxSidebarNavigationItem": any;
        "ifxSidebarActionItem": any;
    }
    interface HTMLIfxSidebarItemElement extends Components.IfxSidebarItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxSidebarItemElementEventMap>(type: K, listener: (this: HTMLIfxSidebarItemElement, ev: IfxSidebarItemCustomEvent<HTMLIfxSidebarItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxSidebarItemElementEventMap>(type: K, listener: (this: HTMLIfxSidebarItemElement, ev: IfxSidebarItemCustomEvent<HTMLIfxSidebarItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxSidebarItemElement: {
        prototype: HTMLIfxSidebarItemElement;
        new (): HTMLIfxSidebarItemElement;
    };
    interface HTMLIfxSidebarTitleElement extends Components.IfxSidebarTitle, HTMLStencilElement {
    }
    var HTMLIfxSidebarTitleElement: {
        prototype: HTMLIfxSidebarTitleElement;
        new (): HTMLIfxSidebarTitleElement;
    };
    interface HTMLIfxSliderElementEventMap {
        "ifxChange": any;
    }
    interface HTMLIfxSliderElement extends Components.IfxSlider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxSliderElementEventMap>(type: K, listener: (this: HTMLIfxSliderElement, ev: IfxSliderCustomEvent<HTMLIfxSliderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxSliderElementEventMap>(type: K, listener: (this: HTMLIfxSliderElement, ev: IfxSliderCustomEvent<HTMLIfxSliderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxSliderElement: {
        prototype: HTMLIfxSliderElement;
        new (): HTMLIfxSliderElement;
    };
    interface HTMLIfxSpinnerElement extends Components.IfxSpinner, HTMLStencilElement {
    }
    var HTMLIfxSpinnerElement: {
        prototype: HTMLIfxSpinnerElement;
        new (): HTMLIfxSpinnerElement;
    };
    interface HTMLIfxStatusElement extends Components.IfxStatus, HTMLStencilElement {
    }
    var HTMLIfxStatusElement: {
        prototype: HTMLIfxStatusElement;
        new (): HTMLIfxStatusElement;
    };
    interface HTMLIfxStepElement extends Components.IfxStep, HTMLStencilElement {
    }
    var HTMLIfxStepElement: {
        prototype: HTMLIfxStepElement;
        new (): HTMLIfxStepElement;
    };
    interface HTMLIfxStepperElementEventMap {
        "ifxChange": any;
    }
    interface HTMLIfxStepperElement extends Components.IfxStepper, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxStepperElementEventMap>(type: K, listener: (this: HTMLIfxStepperElement, ev: IfxStepperCustomEvent<HTMLIfxStepperElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxStepperElementEventMap>(type: K, listener: (this: HTMLIfxStepperElement, ev: IfxStepperCustomEvent<HTMLIfxStepperElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxStepperElement: {
        prototype: HTMLIfxStepperElement;
        new (): HTMLIfxStepperElement;
    };
    interface HTMLIfxSwitchElementEventMap {
        "ifxChange": boolean;
    }
    /**
     * A toggle switch component for binary on/off states.
     * This component is form-associated, meaning it can participate in HTML forms
     * just like native form controls. It supports form validation, form reset,
     * and browser autofill/restore functionality.
     * Code organization follows the Stencil Style Guide:
     * https://stenciljs.com/docs/style-guide
     * 1. Own Properties (internal, not exposed)
     * 2.
     * @Element (reference to host)
     * 3.
     * @State (internal reactive state)
     * 4.
     * @Prop (public API properties)
     * 5.
     * @Event (emitted events)
     * 6. Lifecycle methods
     * 7.
     * @Listen decorators
     * 8.
     * @Method (public methods)
     * 9. Private methods
     * 10. render()
     * Framework Integration:
     * - Vue: Supports v-model binding on the 'checked' property
     * - Angular: Supports [(ngModel)] and reactive forms (formControl)
     * - React: Standard prop binding and event handling
     * Configuration in stencil.config.ts enables framework-specific bindings.
     */
    interface HTMLIfxSwitchElement extends Components.IfxSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxSwitchElementEventMap>(type: K, listener: (this: HTMLIfxSwitchElement, ev: IfxSwitchCustomEvent<HTMLIfxSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxSwitchElementEventMap>(type: K, listener: (this: HTMLIfxSwitchElement, ev: IfxSwitchCustomEvent<HTMLIfxSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxSwitchElement: {
        prototype: HTMLIfxSwitchElement;
        new (): HTMLIfxSwitchElement;
    };
    interface HTMLIfxTabElementEventMap {
        "tabHeaderChange": any;
    }
    interface HTMLIfxTabElement extends Components.IfxTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxTabElementEventMap>(type: K, listener: (this: HTMLIfxTabElement, ev: IfxTabCustomEvent<HTMLIfxTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxTabElementEventMap>(type: K, listener: (this: HTMLIfxTabElement, ev: IfxTabCustomEvent<HTMLIfxTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxTabElement: {
        prototype: HTMLIfxTabElement;
        new (): HTMLIfxTabElement;
    };
    interface HTMLIfxTableElementEventMap {
        "ifxSortChange": any;
    }
    interface HTMLIfxTableElement extends Components.IfxTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxTableElementEventMap>(type: K, listener: (this: HTMLIfxTableElement, ev: IfxTableCustomEvent<HTMLIfxTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxTableElementEventMap>(type: K, listener: (this: HTMLIfxTableElement, ev: IfxTableCustomEvent<HTMLIfxTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxTableElement: {
        prototype: HTMLIfxTableElement;
        new (): HTMLIfxTableElement;
    };
    interface HTMLIfxTabsElementEventMap {
        "ifxChange": any;
    }
    interface HTMLIfxTabsElement extends Components.IfxTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxTabsElementEventMap>(type: K, listener: (this: HTMLIfxTabsElement, ev: IfxTabsCustomEvent<HTMLIfxTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxTabsElementEventMap>(type: K, listener: (this: HTMLIfxTabsElement, ev: IfxTabsCustomEvent<HTMLIfxTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxTabsElement: {
        prototype: HTMLIfxTabsElement;
        new (): HTMLIfxTabsElement;
    };
    interface HTMLIfxTemplateElementEventMap {
        "toggleTemplates": any;
        "fieldError": any;
    }
    interface HTMLIfxTemplateElement extends Components.IfxTemplate, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxTemplateElementEventMap>(type: K, listener: (this: HTMLIfxTemplateElement, ev: IfxTemplateCustomEvent<HTMLIfxTemplateElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxTemplateElementEventMap>(type: K, listener: (this: HTMLIfxTemplateElement, ev: IfxTemplateCustomEvent<HTMLIfxTemplateElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxTemplateElement: {
        prototype: HTMLIfxTemplateElement;
        new (): HTMLIfxTemplateElement;
    };
    interface HTMLIfxTemplatesUiElement extends Components.IfxTemplatesUi, HTMLStencilElement {
    }
    var HTMLIfxTemplatesUiElement: {
        prototype: HTMLIfxTemplatesUiElement;
        new (): HTMLIfxTemplatesUiElement;
    };
    interface HTMLIfxTextFieldElementEventMap {
        "ifxInput": string;
    }
    interface HTMLIfxTextFieldElement extends Components.IfxTextField, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxTextFieldElementEventMap>(type: K, listener: (this: HTMLIfxTextFieldElement, ev: IfxTextFieldCustomEvent<HTMLIfxTextFieldElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxTextFieldElementEventMap>(type: K, listener: (this: HTMLIfxTextFieldElement, ev: IfxTextFieldCustomEvent<HTMLIfxTextFieldElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxTextFieldElement: {
        prototype: HTMLIfxTextFieldElement;
        new (): HTMLIfxTextFieldElement;
    };
    interface HTMLIfxTextareaElementEventMap {
        "ifxInput": string;
    }
    interface HTMLIfxTextareaElement extends Components.IfxTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxTextareaElementEventMap>(type: K, listener: (this: HTMLIfxTextareaElement, ev: IfxTextareaCustomEvent<HTMLIfxTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxTextareaElementEventMap>(type: K, listener: (this: HTMLIfxTextareaElement, ev: IfxTextareaCustomEvent<HTMLIfxTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxTextareaElement: {
        prototype: HTMLIfxTextareaElement;
        new (): HTMLIfxTextareaElement;
    };
    interface HTMLIfxTooltipElement extends Components.IfxTooltip, HTMLStencilElement {
    }
    var HTMLIfxTooltipElement: {
        prototype: HTMLIfxTooltipElement;
        new (): HTMLIfxTooltipElement;
    };
    interface HTMLIfxTreeViewElementEventMap {
        "ifxTreeViewExpandAllChange": boolean;
        "ifxTreeViewDisableAllChange": boolean;
    }
    interface HTMLIfxTreeViewElement extends Components.IfxTreeView, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxTreeViewElementEventMap>(type: K, listener: (this: HTMLIfxTreeViewElement, ev: IfxTreeViewCustomEvent<HTMLIfxTreeViewElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxTreeViewElementEventMap>(type: K, listener: (this: HTMLIfxTreeViewElement, ev: IfxTreeViewCustomEvent<HTMLIfxTreeViewElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxTreeViewElement: {
        prototype: HTMLIfxTreeViewElement;
        new (): HTMLIfxTreeViewElement;
    };
    interface HTMLIfxTreeViewItemElementEventMap {
        "ifxTreeViewItemExpandChange": TreeViewExpandChangeEvent;
        "ifxTreeViewItemCheckChange": TreeViewCheckChangeEvent;
        "ifxTreeViewItemDisableChange": TreeViewDisableChangeEvent;
    }
    interface HTMLIfxTreeViewItemElement extends Components.IfxTreeViewItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIfxTreeViewItemElementEventMap>(type: K, listener: (this: HTMLIfxTreeViewItemElement, ev: IfxTreeViewItemCustomEvent<HTMLIfxTreeViewItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIfxTreeViewItemElementEventMap>(type: K, listener: (this: HTMLIfxTreeViewItemElement, ev: IfxTreeViewItemCustomEvent<HTMLIfxTreeViewItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIfxTreeViewItemElement: {
        prototype: HTMLIfxTreeViewItemElement;
        new (): HTMLIfxTreeViewItemElement;
    };
    interface HTMLElementTagNameMap {
        "ifx-accordion": HTMLIfxAccordionElement;
        "ifx-accordion-item": HTMLIfxAccordionItemElement;
        "ifx-action-list": HTMLIfxActionListElement;
        "ifx-action-list-item": HTMLIfxActionListItemElement;
        "ifx-ai-label": HTMLIfxAiLabelElement;
        "ifx-alert": HTMLIfxAlertElement;
        "ifx-basic-table": HTMLIfxBasicTableElement;
        "ifx-breadcrumb": HTMLIfxBreadcrumbElement;
        "ifx-breadcrumb-item": HTMLIfxBreadcrumbItemElement;
        "ifx-breadcrumb-item-label": HTMLIfxBreadcrumbItemLabelElement;
        "ifx-button": HTMLIfxButtonElement;
        "ifx-card": HTMLIfxCardElement;
        "ifx-card-headline": HTMLIfxCardHeadlineElement;
        "ifx-card-image": HTMLIfxCardImageElement;
        "ifx-card-links": HTMLIfxCardLinksElement;
        "ifx-card-overline": HTMLIfxCardOverlineElement;
        "ifx-card-text": HTMLIfxCardTextElement;
        "ifx-checkbox": HTMLIfxCheckboxElement;
        "ifx-checkbox-group": HTMLIfxCheckboxGroupElement;
        "ifx-chip": HTMLIfxChipElement;
        "ifx-chip-item": HTMLIfxChipItemElement;
        "ifx-content-switcher": HTMLIfxContentSwitcherElement;
        "ifx-content-switcher-item": HTMLIfxContentSwitcherItemElement;
        "ifx-date-picker": HTMLIfxDatePickerElement;
        "ifx-download": HTMLIfxDownloadElement;
        "ifx-dropdown": HTMLIfxDropdownElement;
        "ifx-dropdown-header": HTMLIfxDropdownHeaderElement;
        "ifx-dropdown-item": HTMLIfxDropdownItemElement;
        "ifx-dropdown-menu": HTMLIfxDropdownMenuElement;
        "ifx-dropdown-separator": HTMLIfxDropdownSeparatorElement;
        "ifx-dropdown-trigger": HTMLIfxDropdownTriggerElement;
        "ifx-dropdown-trigger-button": HTMLIfxDropdownTriggerButtonElement;
        "ifx-faq": HTMLIfxFaqElement;
        "ifx-file-upload": HTMLIfxFileUploadElement;
        "ifx-filter-accordion": HTMLIfxFilterAccordionElement;
        "ifx-filter-bar": HTMLIfxFilterBarElement;
        "ifx-filter-search": HTMLIfxFilterSearchElement;
        "ifx-filter-type-group": HTMLIfxFilterTypeGroupElement;
        "ifx-footer": HTMLIfxFooterElement;
        "ifx-footer-column": HTMLIfxFooterColumnElement;
        "ifx-icon": HTMLIfxIconElement;
        "ifx-icon-button": HTMLIfxIconButtonElement;
        "ifx-icons-preview": HTMLIfxIconsPreviewElement;
        "ifx-indicator": HTMLIfxIndicatorElement;
        "ifx-link": HTMLIfxLinkElement;
        "ifx-list": HTMLIfxListElement;
        "ifx-list-entry": HTMLIfxListEntryElement;
        "ifx-modal": HTMLIfxModalElement;
        "ifx-multiselect": HTMLIfxMultiselectElement;
        "ifx-multiselect-option": HTMLIfxMultiselectOptionElement;
        "ifx-navbar": HTMLIfxNavbarElement;
        "ifx-navbar-item": HTMLIfxNavbarItemElement;
        "ifx-navbar-profile": HTMLIfxNavbarProfileElement;
        "ifx-notification": HTMLIfxNotificationElement;
        "ifx-overview-table": HTMLIfxOverviewTableElement;
        "ifx-pagination": HTMLIfxPaginationElement;
        "ifx-popover": HTMLIfxPopoverElement;
        "ifx-progress-bar": HTMLIfxProgressBarElement;
        "ifx-radio-button": HTMLIfxRadioButtonElement;
        "ifx-radio-button-group": HTMLIfxRadioButtonGroupElement;
        "ifx-search-bar": HTMLIfxSearchBarElement;
        "ifx-search-field": HTMLIfxSearchFieldElement;
        "ifx-segment": HTMLIfxSegmentElement;
        "ifx-segmented-control": HTMLIfxSegmentedControlElement;
        "ifx-select": HTMLIfxSelectElement;
        "ifx-set-filter": HTMLIfxSetFilterElement;
        "ifx-sidebar": HTMLIfxSidebarElement;
        "ifx-sidebar-item": HTMLIfxSidebarItemElement;
        "ifx-sidebar-title": HTMLIfxSidebarTitleElement;
        "ifx-slider": HTMLIfxSliderElement;
        "ifx-spinner": HTMLIfxSpinnerElement;
        "ifx-status": HTMLIfxStatusElement;
        "ifx-step": HTMLIfxStepElement;
        "ifx-stepper": HTMLIfxStepperElement;
        "ifx-switch": HTMLIfxSwitchElement;
        "ifx-tab": HTMLIfxTabElement;
        "ifx-table": HTMLIfxTableElement;
        "ifx-tabs": HTMLIfxTabsElement;
        "ifx-template": HTMLIfxTemplateElement;
        "ifx-templates-ui": HTMLIfxTemplatesUiElement;
        "ifx-text-field": HTMLIfxTextFieldElement;
        "ifx-textarea": HTMLIfxTextareaElement;
        "ifx-tooltip": HTMLIfxTooltipElement;
        "ifx-tree-view": HTMLIfxTreeViewElement;
        "ifx-tree-view-item": HTMLIfxTreeViewItemElement;
    }
}
declare namespace LocalJSX {
    type OneOf<K extends string, PropT, AttrT = PropT> = { [P in K]: PropT } & { [P in `attr:${K}` | `prop:${K}`]?: never } | { [P in `attr:${K}`]: AttrT } & { [P in K | `prop:${K}`]?: never } | { [P in `prop:${K}`]: PropT } & { [P in K | `attr:${K}`]?: never };

    interface IfxAccordion {
        /**
          * @default false
         */
        "autoCollapse"?: boolean;
    }
    interface IfxAccordionItem {
        /**
          * @default 3
         */
        "AriaLevel"?: 3;
        "caption"?: string;
        "onIfxClose"?: (event: IfxAccordionItemCustomEvent<any>) => void;
        "onIfxOpen"?: (event: IfxAccordionItemCustomEvent<any>) => void;
        /**
          * @default false
         */
        "open"?: boolean;
    }
    interface IfxActionList {
        /**
          * Aria label for accessibility support
         */
        "listAriaLabel"?: string;
    }
    interface IfxActionListItem {
        /**
          * The description text displayed below the title
         */
        "description"?: string;
        /**
          * Controls whether the item is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * URL to navigate to when item is clicked
         */
        "href"?: string;
        /**
          * Aria label for accessibility support
         */
        "itemAriaLabel"?: string;
        /**
          * The title text displayed in the item
         */
        "itemTitle"?: string;
        /**
          * Event emitted when the main item area is clicked
         */
        "onIfxActionListItemClick"?: (event: IfxActionListItemCustomEvent<ActionListItemClickEvent>) => void;
        /**
          * Target for the link navigation
          * @default '_self'
         */
        "target"?: string;
        /**
          * Value associated with this item
         */
        "value"?: string;
    }
    interface IfxAiLabel {
        /**
          * Determines whether to show a divider line
          * @default true
         */
        "divider"?: boolean;
        /**
          * Display variant - either label or icon
          * @default 'label'
         */
        "variant"?: 'label' | 'icon';
    }
    interface IfxAlert {
        /**
          * @default "assertive"
         */
        "AriaLive"?: "assertive";
        /**
          * @default true
         */
        "closable"?: boolean;
        "icon"?: string;
        "onIfxClose"?: (event: IfxAlertCustomEvent<any>) => void;
        /**
          * @default "primary"
         */
        "variant"?: "primary" | "success" | "danger" | "warning" | "info";
    }
    interface IfxBasicTable {
        "cols"?: any[] | string;
        /**
          * @default "default"
         */
        "rowHeight"?: string;
        "rows"?: any[] | string;
        /**
          * @default "auto"
         */
        "tableHeight"?: string;
        /**
          * @default "default"
         */
        "variant"?: string;
    }
    interface IfxBreadcrumb {
    }
    interface IfxBreadcrumbItem {
    }
    interface IfxBreadcrumbItemLabel {
        "href"?: string;
        "icon"?: string;
        "onBreadcrumbMenuIconWrapper"?: (event: IfxBreadcrumbItemLabelCustomEvent<HTMLElement>) => void;
        /**
          * @default "_self"
         */
        "target"?: string;
    }
    interface IfxButton {
        "ariaLabel"?: string | null;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "fullWidth"?: boolean;
        "href"?: string;
        /**
          * @default "m"
         */
        "size"?: string;
        /**
          * @default "_self"
         */
        "target"?: string;
        /**
          * @default "default"
         */
        "theme"?: "default" | "danger" | "inverse";
        /**
          * @default "button"
         */
        "type"?: "button" | "submit" | "reset";
        /**
          * @default "primary"
         */
        "variant"?: "primary" | "secondary" | "tertiary";
    }
    interface IfxCard {
        "ariaLabel"?: string | null;
        /**
          * @default "vertical"
         */
        "direction"?: "horizontal" | "vertical";
        /**
          * @default ""
         */
        "href"?: string;
        /**
          * @default "_self"
         */
        "target"?: string;
    }
    interface IfxCardHeadline {
    }
    interface IfxCardImage {
        "alt"?: string;
        "onImgPosition"?: (event: IfxCardImageCustomEvent<any>) => void;
        "position"?: string;
        "src"?: string;
    }
    interface IfxCardLinks {
    }
    interface IfxCardOverline {
    }
    interface IfxCardText {
    }
    interface IfxCheckbox {
        /**
          * The state of the checkbox. When true, the checkbox is checked; when false, it is unchecked.
          * @default false
         */
        "checked"?: boolean;
        /**
          * Indicates whether the checkbox is disabled. When true, the checkbox cannot be interacted with and will have a disabled appearance.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Indicates whether the checkbox is in an error state. When true, the checkbox will have an error appearance.
          * @default false
         */
        "error"?: boolean;
        /**
          * Indicates whether the checkbox is in an indeterminate state. When true, the checkbox will have an indeterminate appearance, which is typically used to indicate a "partially selected" state in a group of checkboxes.
          * @default false
         */
        "indeterminate"?: boolean;
        /**
          * Event emitted when the checkbox state changes. Emits the new checked state as a boolean value.
         */
        "onIfxChange"?: (event: IfxCheckboxCustomEvent<boolean>) => void;
        /**
          * Event emitted when the error state changes. Emits the new error state as a boolean value.
         */
        "onIfxError"?: (event: IfxCheckboxCustomEvent<boolean>) => void;
        /**
          * The size of the checkbox. Can be "m" for medium (default) or "s" for small. This prop controls the overall dimensions of the checkbox and its label.
          * @default "m"
         */
        "size"?: string;
        /**
          * The value associated with the checkbox.  This value is typically submitted with a form when the checkbox is checked.  If not specified, it defaults to "on" when the checkbox is checked.
         */
        "value"?: string;
    }
    interface IfxCheckboxGroup {
        /**
          * @default "vertical"
         */
        "alignment"?: "horizontal" | "vertical";
        "captionText"?: string;
        /**
          * @default "Group Label Text"
         */
        "groupLabelText"?: string;
        /**
          * @default false
         */
        "required"?: boolean;
        "showCaption"?: boolean;
        "showCaptionIcon"?: boolean;
        "showGroupLabel"?: boolean;
        "size"?: string;
    }
    interface IfxChip {
        "ariaLabel"?: string | null;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default ""
         */
        "icon"?: string;
        "onIfxChange"?: (event: IfxChipCustomEvent<{
		previousSelection: Array<ChipItemSelectEvent>;
		currentSelection: Array<ChipItemSelectEvent>;
		name: string;
	}>) => void;
        /**
          * @default ""
         */
        "placeholder"?: string;
        /**
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * @default "medium"
         */
        "size"?: "small" | "medium" | "large";
        /**
          * @default "outlined"
         */
        "theme"?: "outlined" | "filled-light" | "filled-dark";
        /**
          * @default undefined
         */
        "value"?: Array<string> | string;
        /**
          * @default "single"
         */
        "variant"?: "single" | "multi";
    }
    interface IfxChipItem {
        /**
          * @default { 		emitIfxChipItemSelect: true, 		variant: "multi", 		size: "large", 	}
         */
        "chipState"?: ChipState;
        "onIfxChipItemSelect"?: (event: IfxChipItemCustomEvent<ChipItemSelectEvent>) => void;
        /**
          * @default false
         */
        "selected"?: boolean;
        /**
          * @default undefined
         */
        "value"?: string;
    }
    interface IfxContentSwitcher {
        "onIfxChange"?: (event: IfxContentSwitcherCustomEvent<ChangeEvent>) => void;
    }
    interface IfxContentSwitcherItem {
        /**
          * @default false
         */
        "selected"?: boolean;
        "value"?: string;
    }
    interface IfxDatePicker {
        /**
          * Aria label for the date picker input
         */
        "ariaLabelText"?: string | null;
        /**
          * Autocomplete attribute for the input
          * @default "on"
         */
        "autocomplete"?: string;
        /**
          * Caption text displayed below the date picker
         */
        "caption"?: string;
        /**
          * Whether the date picker is disabled
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Error state of the date picker
          * @default false
         */
        "error"?: boolean;
        /**
          * Label text for the date picker
         */
        "label"?: string;
        /**
          * Maximum allowed date
         */
        "max"?: string;
        /**
          * Minimum allowed date
         */
        "min"?: string;
        /**
          * Event emitted when date value changes
         */
        "onIfxDate"?: (event: IfxDatePickerCustomEvent<any>) => void;
        /**
          * Whether the date picker is required
          * @default false
         */
        "required"?: boolean;
        /**
          * Size of the date picker input
          * @default "s"
         */
        "size"?: string;
        /**
          * Success state of the date picker
          * @default false
         */
        "success"?: boolean;
        /**
          * Type of date input (date, datetime-local, etc.)
          * @default "date"
         */
        "type"?: string;
        /**
          * The value of the date picker
         */
        "value"?: string;
    }
    interface IfxDownload {
        /**
          * @default "css"
         */
        "tokens"?: "css" | "scss";
    }
    interface IfxDropdown {
        /**
          * @default false
         */
        "defaultOpen"?: boolean;
        "disabled"?: boolean;
        /**
          * @default false
         */
        "noAppendToBody"?: boolean;
        /**
          * @default false
         */
        "noCloseOnMenuClick"?: boolean;
        /**
          * @default false
         */
        "noCloseOnOutsideClick"?: boolean;
        "onIfxClose"?: (event: IfxDropdownCustomEvent<any>) => void;
        "onIfxDropdown"?: (event: IfxDropdownCustomEvent<any>) => void;
        "onIfxOpen"?: (event: IfxDropdownCustomEvent<any>) => void;
        /**
          * @default "bottom-start"
         */
        "placement"?: Placement;
    }
    interface IfxDropdownHeader {
    }
    interface IfxDropdownItem {
        /**
          * @default false
         */
        "error"?: boolean;
        /**
          * @default false
         */
        "hide"?: boolean;
        /**
          * @default ""
         */
        "href"?: string;
        "icon"?: string;
        "onIfxDropdownItem"?: (event: IfxDropdownItemCustomEvent<any>) => void;
        /**
          * @default "_self"
         */
        "target"?: string;
    }
    interface IfxDropdownMenu {
        /**
          * @default false
         */
        "isOpen"?: boolean;
        "onIfxDropdownMenuItem"?: (event: IfxDropdownMenuCustomEvent<CustomEvent>) => void;
        "onMenuSize"?: (event: IfxDropdownMenuCustomEvent<any>) => void;
        /**
          * @default "l"
         */
        "size"?: string;
    }
    interface IfxDropdownSeparator {
    }
    interface IfxDropdownTrigger {
        /**
          * @default false
         */
        "isOpen"?: boolean;
    }
    interface IfxDropdownTriggerButton {
        "disabled"?: boolean;
        /**
          * @default false
         */
        "hideArrow"?: boolean;
        /**
          * @default false
         */
        "isOpen"?: boolean;
        /**
          * @default "m"
         */
        "size"?: "s" | "m";
        /**
          * @default "default"
         */
        "theme"?: "default" | "danger" | "inverse";
        "variant"?: "primary";
    }
    interface IfxFaq {
    }
    interface IfxFileUpload {
        /**
          * @default []
         */
        "additionalAllowedFileTypes"?: string | string[];
        /**
          * When set to true, allows any file type to be uploaded (no file type restrictions).
          * @default false
         */
        "allowAnyFileType"?: boolean;
        /**
          * Custom file extensions to allow (e.g., 'xml', 'asc', 'cfg'). Recommended format: without dots. Also accepts format with dots like '.xml'. Do not use wildcards like '*.xml'.
          * @default []
         */
        "allowedFileExtensions"?: string | string[];
        /**
          * Default set of allowed file extensions (used internally). Can be extended using `additionalAllowedFileTypes`.
          * @default undefined
         */
        "allowedFileTypes"?: string | string[];
        /**
          * @default "Browse files"
         */
        "ariaLabelBrowseFiles"?: string;
        /**
          * @default "Cancel upload"
         */
        "ariaLabelCancelUpload"?: string;
        /**
          * @default "Upload area. Click to browse or drag and drop files."
         */
        "ariaLabelDropzone"?: string;
        /**
          * @default "Upload file"
         */
        "ariaLabelFileInput"?: string;
        /**
          * @default "Remove file"
         */
        "ariaLabelRemoveFile"?: string;
        /**
          * @default "Retry upload"
         */
        "ariaLabelRetryUpload"?: string;
        /**
          * @default "Upload failed"
         */
        "ariaLabelUploadFailedStatus"?: string;
        /**
          * @default "Upload completed"
         */
        "ariaLabelUploadedStatus"?: string;
        /**
          * @default "Upload in progress"
         */
        "ariaLabelUploadingStatus"?: string;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "dragAndDrop"?: boolean;
        /**
          * @default "Label"
         */
        "label"?: string;
        /**
          * @default "Browse files"
         */
        "labelBrowseFiles"?: string;
        /**
          * @default "Drag & Drop or browse files to upload"
         */
        "labelDragAndDrop"?: string;
        /**
          * @default "files"
         */
        "labelFilePlural"?: string;
        /**
          * @default "file"
         */
        "labelFileSingular"?: string;
        /**
          * @default "Upload failed. Max file size: {{size}}MB."
         */
        "labelFileTooLarge"?: string;
        /**
          * @default "Upload limit exceeded. Only {{count}} {{files}} allowed."
         */
        "labelMaxFilesExceeded"?: string;
        /**
          * @default "Up to {{count}} {{files}}."
         */
        "labelMaxFilesInfo"?: string;
        /**
          * @default "At least one file must be uploaded"
         */
        "labelRequiredError"?: string;
        /**
          * @default "Supported file formats: {{types}}. Max file size: {{size}}MB."
         */
        "labelSupportedFormatsTemplate"?: string;
        /**
          * @default "Unsupported file type."
         */
        "labelUnsupportedFileType"?: string;
        /**
          * @default "Upload failed. Please try again."
         */
        "labelUploadFailed"?: string;
        /**
          * @default "Successfully uploaded"
         */
        "labelUploaded"?: string;
        /**
          * @default "Uploaded files"
         */
        "labelUploadedFilesHeading"?: string;
        /**
          * @default 7
         */
        "maxFileSizeMB"?: number;
        "maxFiles"?: number | undefined;
        "onIfxFileUploadAbort"?: (event: IfxFileUploadCustomEvent<{ file: File }>) => void;
        "onIfxFileUploadAdd"?: (event: IfxFileUploadCustomEvent<{
		addedFiles: File[];
		files: File[];
	}>) => void;
        "onIfxFileUploadAllComplete"?: (event: IfxFileUploadCustomEvent<{ files: File[] }>) => void;
        "onIfxFileUploadChange"?: (event: IfxFileUploadCustomEvent<{ files: File[] }>) => void;
        "onIfxFileUploadClick"?: (event: IfxFileUploadCustomEvent<void>) => void;
        "onIfxFileUploadComplete"?: (event: IfxFileUploadCustomEvent<{ file: File }>) => void;
        "onIfxFileUploadDrop"?: (event: IfxFileUploadCustomEvent<{
		droppedFiles: File[];
		acceptedFiles: File[];
		rejectedFiles: File[];
	}>) => void;
        "onIfxFileUploadError"?: (event: IfxFileUploadCustomEvent<{
		errorType: string;
		file: File;
		message: string;
		reason?: string;
	}>) => void;
        "onIfxFileUploadInvalid"?: (event: IfxFileUploadCustomEvent<{ file: File; reason: string }>) => void;
        "onIfxFileUploadMaxFilesExceeded"?: (event: IfxFileUploadCustomEvent<{
		maxFiles: number;
		attempted: number;
	}>) => void;
        "onIfxFileUploadRemove"?: (event: IfxFileUploadCustomEvent<{
		removedFile: File;
		files: File[];
	}>) => void;
        "onIfxFileUploadRetry"?: (event: IfxFileUploadCustomEvent<{ file: File }>) => void;
        "onIfxFileUploadStart"?: (event: IfxFileUploadCustomEvent<{ file: File }>) => void;
        "onIfxFileUploadValidation"?: (event: IfxFileUploadCustomEvent<{ valid: boolean }>) => void;
        /**
          * @default false
         */
        "required"?: boolean;
        "uploadHandler"?: (
		file: File,
		onProgress?: (progress: number) => void,
	) => Promise<void>;
    }
    interface IfxFilterAccordion {
        /**
          * @default ""
         */
        "filterGroupName"?: "";
        "maxVisibleItems"?: number;
        "onIfxFilterAccordionChange"?: (event: IfxFilterAccordionCustomEvent<any>) => void;
    }
    interface IfxFilterBar {
        /**
          * @default 4
         */
        "maxShownFilters"?: number;
        "onIfxTopbarFilterChange"?: (event: IfxFilterBarCustomEvent<any>) => void;
        /**
          * @default true
         */
        "showMoreFiltersButton"?: boolean;
    }
    interface IfxFilterSearch {
        /**
          * @default false
         */
        "disabled"?: boolean;
        "filterKey"?: string;
        "filterName"?: string;
        /**
          * @default "sidebar"
         */
        "filterOrientation"?: string;
        "filterValue"?: string;
        "onIfxFilterSearchChange"?: (event: IfxFilterSearchCustomEvent<any>) => void;
        "placeholder"?: string;
    }
    interface IfxFilterTypeGroup {
        "onIfxSidebarFilterChange"?: (event: IfxFilterTypeGroupCustomEvent<any>) => void;
    }
    interface IfxFooter {
        /**
          * @default "© 1999 - " + this.currentYear + " Infineon Technologies AG"
         */
        "copyrightText"?: string;
    }
    interface IfxFooterColumn {
    }
    interface IfxIcon {
        /**
          * @default ""
         */
        "icon"?: string;
        "ifxIcon"?: any;
        "onConsoleError"?: (event: IfxIconCustomEvent<boolean>) => void;
    }
    interface IfxIconButton {
        "ariaLabel"?: string | null;
        "disabled"?: boolean;
        "href"?: string;
        "icon"?: string;
        /**
          * @default "round"
         */
        "shape"?: string;
        "size"?: string;
        /**
          * @default "_self"
         */
        "target"?: string;
        "variant"?: "primary" | "secondary" | "tertiary";
    }
    interface IfxIconsPreview {
    }
    interface IfxIndicator {
        "ariaLabel"?: string | null;
        /**
          * @default false
         */
        "inverted"?: boolean;
        /**
          * @default 0
         */
        "number"?: number;
        /**
          * @default "number"
         */
        "variant"?: string;
    }
    interface IfxLink {
        "ariaLabel"?: string | null;
        /**
          * @default false
         */
        "disabled"?: boolean;
        "download"?: string;
        /**
          * @default undefined
         */
        "href"?: string;
        "size"?: string;
        /**
          * @default "_self"
         */
        "target"?: string;
        /**
          * @default "bold"
         */
        "variant"?: string;
    }
    interface IfxList {
        /**
          * @default 6
         */
        "maxVisibleItems"?: 6;
        /**
          * @default ""
         */
        "name"?: "";
        "onIfxListUpdate"?: (event: IfxListCustomEvent<any>) => void;
        "resetTrigger"?: boolean;
        /**
          * @default "checkbox"
         */
        "type"?: string;
    }
    interface IfxListEntry {
        "label"?: string;
        "onIfxListEntryChange"?: (event: IfxListEntryCustomEvent<any>) => void;
        "type"?: string;
        "value"?: boolean;
    }
    interface IfxModal {
        /**
          * @default ""
         */
        "alertIcon"?: string;
        /**
          * @default "Cancel"
         */
        "cancelButtonLabel"?: string;
        /**
          * @default "Modal Title"
         */
        "caption"?: string;
        "captionAriaLabel"?: string | null;
        "closeButtonAriaLabel"?: string | null;
        /**
          * @default true
         */
        "closeOnOverlayClick"?: boolean;
        /**
          * @default "OK"
         */
        "okButtonLabel"?: string;
        "onIfxClose"?: (event: IfxModalCustomEvent<any>) => void;
        "onIfxOpen"?: (event: IfxModalCustomEvent<any>) => void;
        /**
          * @default false
         */
        "opened"?: boolean;
        /**
          * @default true
         */
        "showCloseButton"?: boolean;
        /**
          * @default "s"
         */
        "size"?: "s" | "m" | "l";
        /**
          * @default "default"
         */
        "variant"?: "default" | "alert-brand" | "alert-danger";
    }
    interface IfxMultiselect {
        /**
          * @default "Clear all selections"
         */
        "ariaClearLabel"?: string;
        /**
          * @default "Collapse all categories"
         */
        "ariaCollapseAllLabel"?: string;
        /**
          * @default "Expand all categories"
         */
        "ariaExpandAllLabel"?: string;
        /**
          * @default ""
         */
        "ariaMultiSelectDescribedBy"?: string;
        /**
          * @default "Multi-select dropdown"
         */
        "ariaMultiSelectLabel"?: string;
        /**
          * @default ""
         */
        "ariaMultiSelectLabelledBy"?: string;
        /**
          * @default "Search options"
         */
        "ariaSearchLabel"?: string;
        /**
          * @default "Select all options"
         */
        "ariaSelectAllLabel"?: string;
        /**
          * @default "Toggle dropdown"
         */
        "ariaToggleLabel"?: string;
        /**
          * @default ""
         */
        "caption"?: string;
        /**
          * @default "Collapse"
         */
        "collapseLabel"?: string;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        /**
          * @default "Expand"
         */
        "expandLabel"?: string;
        /**
          * @default ""
         */
        "label"?: string;
        "name"?: string;
        /**
          * @default "No results found."
         */
        "noResultsMessage"?: string;
        "onIfxOpen"?: (event: IfxMultiselectCustomEvent<any>) => void;
        "onIfxSelect"?: (event: IfxMultiselectCustomEvent<any>) => void;
        /**
          * @default ""
         */
        "placeholder"?: string;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default "Search"
         */
        "searchPlaceholder"?: string;
        /**
          * @default "Select all"
         */
        "selectAllLabel"?: string;
        /**
          * @default true
         */
        "showClearButton"?: boolean;
        /**
          * @default true
         */
        "showExpandCollapse"?: boolean;
        /**
          * @default true
         */
        "showNoResultsMessage"?: boolean;
        /**
          * @default true
         */
        "showSearch"?: boolean;
        /**
          * @default true
         */
        "showSelectAll"?: boolean;
    }
    interface IfxMultiselectOption {
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "indeterminate"?: boolean;
        /**
          * @default false
         */
        "selected"?: boolean;
        "value"?: string;
    }
    interface IfxNavbar {
        /**
          * @default ""
         */
        "applicationName"?: string;
        /**
          * @default true
         */
        "fixed"?: boolean;
        /**
          * @default ""
         */
        "logoHref"?: string;
        /**
          * @default "_self"
         */
        "logoHrefTarget"?: string;
        "onIfxNavbarMobileMenuIsOpen"?: (event: IfxNavbarCustomEvent<any>) => void;
        /**
          * @default true
         */
        "showLogoAndAppname"?: boolean;
    }
    interface IfxNavbarItem {
        /**
          * @default false
         */
        "dotIndicator"?: boolean;
        /**
          * @default true
         */
        "hideOnMobile"?: boolean;
        /**
          * @default ""
         */
        "href"?: string;
        /**
          * @default ""
         */
        "icon"?: string;
        "numberIndicator"?: number;
        "onIfxNavItem"?: (event: IfxNavbarItemCustomEvent<any>) => void;
        /**
          * @default true
         */
        "showLabel"?: boolean;
        /**
          * @default "_self"
         */
        "target"?: string;
    }
    interface IfxNavbarProfile {
        /**
          * @default ""
         */
        "alt"?: string;
        /**
          * @default ""
         */
        "href"?: string;
        /**
          * @default ""
         */
        "imageUrl"?: string;
        /**
          * @default true
         */
        "showLabel"?: boolean;
        /**
          * @default "_self"
         */
        "target"?: string;
        /**
          * @default ""
         */
        "userName"?: string;
    }
    interface IfxNotification {
        "icon"?: string;
        "linkHref"?: string;
        /**
          * @default "_blank"
         */
        "linkTarget"?: string;
        "linkText"?: string;
        /**
          * @default "success"
         */
        "variant"?: NotificationVariant;
    }
    interface IfxOverviewTable {
    }
    interface IfxPagination {
        /**
          * @default 1
         */
        "currentPage"?: number;
        "itemsPerPage"?: any[] | string;
        "onIfxItemsPerPageChange"?: (event: IfxPaginationCustomEvent<any>) => void;
        "onIfxPageChange"?: (event: IfxPaginationCustomEvent<any>) => void;
        /**
          * @default true
         */
        "showItemsPerPage"?: boolean;
        /**
          * @default 1
         */
        "total"?: number;
    }
    interface IfxPopover {
        /**
          * Accessible label for the popover
          * @default null
         */
        "ariaLabel"?: string | null;
        /**
          * Whether the popover is disabled
          * @default false
         */
        "disabled"?: boolean;
        "onIfxClose"?: (event: IfxPopoverCustomEvent<any>) => void;
        /**
          * Emitted when the popover is opened
         */
        "onIfxOpen"?: (event: IfxPopoverCustomEvent<{ trigger: HTMLElement | null }>) => void;
        /**
          * Whether the popover is initially open
          * @default false
         */
        "open"?: boolean;
        /**
          * Title text displayed in the popover header
          * @default ''
         */
        "popoverTitle"?: string;
        /**
          * Position of the popover relative to the trigger element
          * @default 'auto'
         */
        "position"?: 'bottom-start' | 'top-start' | 'left' | 'bottom-end' | 'top-end' | 'right' | 'bottom' | 'top' | 'auto';
        /**
          * Body text displayed in the popover content
          * @default ''
         */
        "text"?: string;
    }
    interface IfxProgressBar {
        /**
          * @default false
         */
        "showLabel"?: boolean;
        "size"?: string;
        /**
          * @default 0
         */
        "value"?: number;
    }
    interface IfxRadioButton {
        "checked"?: boolean;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        "name"?: string;
        "onIfxChange"?: (event: IfxRadioButtonCustomEvent<any>) => void;
        "onIfxError"?: (event: IfxRadioButtonCustomEvent<any>) => void;
        /**
          * @default "s"
         */
        "size"?: "s" | "m";
        "value"?: string;
    }
    interface IfxRadioButtonGroup {
        /**
          * @default "vertical"
         */
        "alignment"?: "horizontal" | "vertical";
        "captionText"?: string;
        /**
          * @default "Group Label Text"
         */
        "groupLabelText"?: string;
        /**
          * @default false
         */
        "required"?: boolean;
        "showCaption"?: boolean;
        "showCaptionIcon"?: boolean;
        "showGroupLabel"?: boolean;
        "size"?: string;
    }
    interface IfxSearchBar {
        /**
          * @default "on"
         */
        "autocomplete"?: string;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default true
         */
        "isOpen"?: boolean;
        "maxlength"?: number;
        "onIfxInput"?: (event: IfxSearchBarCustomEvent<any>) => void;
        "onIfxOpen"?: (event: IfxSearchBarCustomEvent<any>) => void;
        "value"?: string;
    }
    interface IfxSearchField {
        "ariaDescribedBy"?: string | null;
        /**
          * @default "Search Field"
         */
        "ariaLabel"?: string | null;
        "ariaLabelledBy"?: string | null;
        /**
          * @default "off"
         */
        "autocomplete"?: string;
        /**
          * @default "Clear search"
         */
        "deleteIconAriaLabel"?: string;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default "Search suggestions and history"
         */
        "dropdownAriaLabel"?: string;
        /**
          * @default true
         */
        "enableHistory"?: boolean;
        /**
          * @default "Remove from history"
         */
        "historyDeleteAriaLabel"?: string;
        /**
          * @default "Recent Searches"
         */
        "historyHeaderText"?: string;
        /**
          * @default "Search history item"
         */
        "historyItemAriaLabel"?: string;
        /**
          * @default "ifx-search-history"
         */
        "historyKey"?: string;
        /**
          * @default 5
         */
        "maxHistoryItems"?: number;
        /**
          * @default 10
         */
        "maxSuggestions"?: number;
        /**
          * @default null
         */
        "maxlength"?: number;
        "onIfxBlur"?: (event: IfxSearchFieldCustomEvent<void>) => void;
        "onIfxFocus"?: (event: IfxSearchFieldCustomEvent<void>) => void;
        "onIfxInput"?: (event: IfxSearchFieldCustomEvent<string>) => void;
        "onIfxSuggestionRequested"?: (event: IfxSearchFieldCustomEvent<string>) => void;
        "onIfxSuggestionSelected"?: (event: IfxSearchFieldCustomEvent<SuggestionItem>) => void;
        /**
          * @default "Search..."
         */
        "placeholder"?: string;
        /**
          * @default false
         */
        "showDeleteIcon"?: boolean;
        /**
          * @default false
         */
        "showSuggestions"?: boolean;
        /**
          * @default "l"
         */
        "size"?: string;
        /**
          * @default "Search suggestion"
         */
        "suggestionAriaLabel"?: string;
        /**
          * @default []
         */
        "suggestions"?: SuggestionItem[];
        /**
          * @default ""
         */
        "value"?: string;
    }
    interface IfxSegment {
        "icon"?: string;
        "onSegmentSelect"?: (event: IfxSegmentCustomEvent<number>) => void;
        "segmentIndex"?: number;
        /**
          * @default false
         */
        "selected"?: boolean;
        "value": string;
    }
    interface IfxSegmentedControl {
        /**
          * @default ""
         */
        "caption"?: string;
        /**
          * @default false
         */
        "error"?: boolean;
        /**
          * @default ""
         */
        "label"?: string;
        "onIfxChange"?: (event: IfxSegmentedControlCustomEvent<{
		previousValue: string;
		selectedValue: string;
	}>) => void;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default "regular"
         */
        "size"?: "regular" | "small";
    }
    interface IfxSelect {
        "addItemFilter"?: string | RegExp | ItemFilterFn;
        "addItemText"?: string | AddItemTextFn;
        "addItems"?: boolean;
        "appendValue"?: string;
        "callbackOnCreateTemplates"?: OnCreateTemplates;
        "callbackOnInit"?: OnInit;
        /**
          * @default ''
         */
        "caption"?: string;
        /**
          * @default undefined
         */
        "choices"?: Array<any> | string;
        "classNames"?: ClassNames;
        "customAddItemText"?: CustomAddItemText;
        "delimiter"?: string;
        /**
          * @default false
         */
        "disabled"?: boolean;
        "duplicateItemsAllowed"?: boolean;
        "editItems"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        "fuseOptions"?: FuseOptions;
        "itemSelectText"?: '';
        "items"?: Array<any>;
        /**
          * @default ''
         */
        "label"?: string;
        "loadingText"?: string;
        "maxItemCount"?: number;
        "maxItemText"?: string | MaxItemTextFn;
        "name"?: string;
        "noChoicesText"?: string | NoChoicesTextFn;
        "noResultsText"?: string | NoResultsTextFn;
        "onIfxInput"?: (event: IfxSelectCustomEvent<CustomEvent>) => void;
        "onIfxSelect"?: (event: IfxSelectCustomEvent<CustomEvent>) => void;
        "options"?: any[] | string;
        "paste"?: boolean;
        "placeholder"?: boolean | string;
        /**
          * @default 'Placeholder'
         */
        "placeholderValue"?: string;
        "position"?: 'auto' | 'top' | 'bottom';
        "prependValue"?: string;
        "removeItemButton"?: boolean;
        "removeItems"?: boolean;
        "renderChoiceLimit"?: number;
        "renderSelectedChoices"?: 'always' | 'auto';
        /**
          * @default false
         */
        "required"?: boolean;
        "resetScrollPosition"?: boolean;
        "searchChoices"?: boolean;
        "searchFields"?: Array<string> | string;
        "searchFloor"?: number;
        "searchPlaceholderValue"?: string;
        "searchResultLimit"?: number;
        "shouldSort"?: boolean;
        "shouldSortItems"?: boolean;
        /**
          * @default true
         */
        "showClearButton"?: boolean;
        "showSearch"?: boolean;
        /**
          * @default 'medium (40px)'
         */
        "size"?: string;
        "sorter"?: SortFn;
        "uniqueItemText"?: UniqueItemText;
        "value"?: string;
        "valueComparer"?: ValueCompareFunction;
    }
    interface IfxSetFilter {
        "filterLabel"?: string;
        "filterName"?: string;
        "onIfxFilterSelect"?: (event: IfxSetFilterCustomEvent<any>) => void;
        "options"?: any[] | string;
        "placeholder"?: string;
        /**
          * @default "text"
         */
        "type"?: "text" | "single-select" | "multi-select";
    }
    interface IfxSidebar {
        /**
          * @default ""
         */
        "applicationName"?: string;
        /**
          * @default false
         */
        "collapsed"?: boolean;
        /**
          * @default false
         */
        "collapsible"?: boolean;
        /**
          * @default "© 1999 - " + this.currentYear + " Infineon Technologies AG"
         */
        "copyrightText"?: string;
        /**
          * @default "Hide Menu"
         */
        "hideMenuLabel"?: string;
        /**
          * @default "#"
         */
        "imprint"?: string;
        /**
          * @default true
         */
        "initialCollapse"?: boolean;
        "onIfxSidebarCollapseChange"?: (event: IfxSidebarCustomEvent<{ collapsed: boolean }>) => void;
        /**
          * @default "#"
         */
        "privacyPolicy"?: string;
        /**
          * @default true
         */
        "showFooter"?: boolean;
        /**
          * @default true
         */
        "showHeader"?: boolean;
        /**
          * @default "_blank"
         */
        "target"?: string;
        /**
          * @default "#"
         */
        "termsOfUse"?: string;
    }
    interface IfxSidebarItem {
        /**
          * @default false
         */
        "active"?: boolean;
        "handleItemClick"?: (item: HTMLElement) => void;
        /**
          * @default ""
         */
        "href"?: string;
        /**
          * @default ""
         */
        "icon"?: string;
        /**
          * @default false
         */
        "isActionItem"?: boolean;
        "numberIndicator"?: number;
        "onIfxSidebarActionItem"?: (event: IfxSidebarItemCustomEvent<any>) => void;
        "onIfxSidebarMenu"?: (event: IfxSidebarItemCustomEvent<any>) => void;
        "onIfxSidebarNavigationItem"?: (event: IfxSidebarItemCustomEvent<any>) => void;
        /**
          * @default "_self"
         */
        "target"?: string;
    }
    interface IfxSidebarTitle {
        /**
          * @default false
         */
        "showInCollapsed"?: boolean;
    }
    interface IfxSlider {
        "ariaLabel"?: string | null;
        /**
          * @default false
         */
        "disabled"?: boolean;
        "leftIcon"?: string;
        "leftText"?: string;
        /**
          * @default 100
         */
        "max"?: number;
        "maxValueHandle"?: number;
        /**
          * @default 0
         */
        "min"?: number;
        "minValueHandle"?: number;
        "onIfxChange"?: (event: IfxSliderCustomEvent<any>) => void;
        "rightIcon"?: string;
        "rightText"?: string;
        /**
          * @default false
         */
        "showPercentage"?: boolean;
        /**
          * @default 1
         */
        "step"?: number;
        /**
          * @default "single"
         */
        "type"?: "single" | "double";
        "value"?: number;
    }
    interface IfxSpinner {
        "ariaLabel"?: string | null;
        /**
          * @default false
         */
        "inverted"?: boolean;
        "size"?: string;
        "variant"?: string;
    }
    interface IfxStatus {
        /**
          * @default false
         */
        "border"?: boolean;
        /**
          * @default "orange-500"
         */
        "color"?: string;
        "label"?: string;
    }
    interface IfxStep {
        /**
          * @default false
         */
        "complete"?: boolean;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        /**
          * @default false
         */
        "lastStep"?: boolean;
        /**
          * @default 1
         */
        "stepId"?: number;
        /**
          * @default { 		activeStep: 1, 		showStepNumber: false, 		variant: "default", 		indicatorPosition: "left", 	}
         */
        "stepperState"?: StepperState;
    }
    interface IfxStepper {
        /**
          * @default 1
         */
        "activeStep"?: number;
        "ariaCurrent"?: string | null;
        "ariaLabel"?: string | null;
        /**
          * @default "left"
         */
        "indicatorPosition"?: "left" | "right";
        "onIfxChange"?: (event: IfxStepperCustomEvent<any>) => void;
        /**
          * @default false
         */
        "showStepNumber"?: boolean;
        /**
          * @default "default"
         */
        "variant"?: "default" | "compact" | "vertical";
    }
    /**
     * A toggle switch component for binary on/off states.
     * This component is form-associated, meaning it can participate in HTML forms
     * just like native form controls. It supports form validation, form reset,
     * and browser autofill/restore functionality.
     * Code organization follows the Stencil Style Guide:
     * https://stenciljs.com/docs/style-guide
     * 1. Own Properties (internal, not exposed)
     * 2.
     * @Element (reference to host)
     * 3.
     * @State (internal reactive state)
     * 4.
     * @Prop (public API properties)
     * 5.
     * @Event (emitted events)
     * 6. Lifecycle methods
     * 7.
     * @Listen decorators
     * 8.
     * @Method (public methods)
     * 9. Private methods
     * 10. render()
     * Framework Integration:
     * - Vue: Supports v-model binding on the 'checked' property
     * - Angular: Supports [(ngModel)] and reactive forms (formControl)
     * - React: Standard prop binding and event handling
     * Configuration in stencil.config.ts enables framework-specific bindings.
     */
    interface IfxSwitch {
        /**
          * Sets the checked state of the switch.
          * @default false
         */
        "checked"?: boolean;
        /**
          * Disables user interaction when true.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The `id` of a `<form>` element to associate this element with.
         */
        "form"?: string;
        /**
          * Form field name.
          * @default ""
         */
        "name"?: string;
        /**
          * Emitted when checked state changes.
         */
        "onIfxChange"?: (event: IfxSwitchCustomEvent<boolean>) => void;
        /**
          * Form field value when checked. If not set, defaults to "on" (standard checkbox behavior).
          * @default "on"
         */
        "value"?: string;
    }
    interface IfxTab {
        "disabled"?: boolean;
        "header"?: string;
        /**
          * @default ""
         */
        "icon"?: string;
        /**
          * @default "left"
         */
        "iconPosition"?: "left" | "right";
        "onTabHeaderChange"?: (event: IfxTabCustomEvent<any>) => void;
    }
    interface IfxTable {
        /**
          * Options for button renderer including click handler.
         */
        "buttonRendererOptions"?: {
		onButtonClick?: (params: any, event: Event) => void;
	};
        /**
          * Options for checkbox renderer including click handler.
         */
        "checkboxRendererOptions"?: {
		onCheckboxClick?: (params: any, event: Event) => void;
	};
        /**
          * The column definitions for the grid.
         */
        "cols"?: any;
        /**
          * Minimum width for columns.
         */
        "columnMinWidth"?: number;
        /**
          * Fixed width for columns.
         */
        "columnWidth"?: string;
        /**
          * Enable row selection.
          * @default false
         */
        "enableSelection"?: boolean;
        /**
          * Filter display orientation (sidebar or inline).
          * @default "sidebar"
         */
        "filterOrientation"?: string;
        /**
          * Auto-fit columns to container width.
          * @default false
         */
        "fitColumns"?: boolean;
        /**
          * Headline text displayed above the grid.
          * @default ""
         */
        "headline"?: string;
        /**
          * Numeric value displayed in headline.
          * @default null
         */
        "headlineNumber"?: number;
        /**
          * Options for icon button renderer including click handler.
         */
        "iconButtonRendererOptions"?: {
		onIconButtonClick?: (params: any, event: Event) => void;
	};
        /**
          * Emitted when sort order changes.
         */
        "onIfxSortChange"?: (event: IfxTableCustomEvent<any>) => void;
        /**
          * Enable or disable pagination.
          * @default true
         */
        "pagination"?: boolean;
        /**
          * Number of items per page.
         */
        "paginationItemsPerPage"?: string;
        /**
          * Height of each row.
          * @default "default"
         */
        "rowHeight"?: string;
        /**
          * The rows definitions for the grid.
         */
        "rows"?: any;
        /**
          * Handler for server-side page changes.
         */
        "serverPageChangeHandler"?: (params: {
		page: number;
		pageSize: number;
	}) => Promise<{ rows: any[]; total: number }>;
        /**
          * Enable server-side pagination mode.
          * @default false
         */
        "serverSidePagination"?: boolean;
        /**
          * Show loading overlay.
          * @default false
         */
        "showLoading"?: boolean;
        /**
          * Total height of the table.
          * @default "auto"
         */
        "tableHeight"?: string;
        /**
          * Visual variant of the grid.
          * @default "default"
         */
        "variant"?: string;
    }
    interface IfxTabs {
        /**
          * @default 0
         */
        "activeTabIndex"?: number;
        /**
          * @default false
         */
        "fullWidth"?: boolean;
        "onIfxChange"?: (event: IfxTabsCustomEvent<any>) => void;
        /**
          * @default "horizontal"
         */
        "orientation"?: string;
    }
    interface IfxTemplate {
        "name"?: string;
        "onFieldError"?: (event: IfxTemplateCustomEvent<any>) => void;
        "onToggleTemplates"?: (event: IfxTemplateCustomEvent<any>) => void;
        "thumbnail"?: string;
    }
    interface IfxTemplatesUi {
    }
    interface IfxTextField {
        /**
          * @default "on"
         */
        "autocomplete"?: string;
        /**
          * @default ""
         */
        "caption"?: string;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        /**
          * @default ""
         */
        "icon"?: string;
        /**
          * @default "text-field"
         */
        "internalId"?: string;
        /**
          * @default ""
         */
        "label"?: string;
        "maxlength"?: number;
        "onIfxInput"?: (event: IfxTextFieldCustomEvent<string>) => void;
        /**
          * @default "Placeholder"
         */
        "placeholder"?: string;
        /**
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default false
         */
        "showDeleteIcon"?: boolean;
        /**
          * @default "m"
         */
        "size"?: string;
        /**
          * @default false
         */
        "success"?: boolean;
        /**
          * @default "text"
         */
        "type"?: "text" | "password";
        /**
          * @default ""
         */
        "value"?: string;
    }
    interface IfxTextarea {
        "caption"?: string;
        "cols"?: number;
        /**
          * @default false
         */
        "disabled"?: boolean;
        /**
          * @default false
         */
        "error"?: boolean;
        /**
          * @default "false"
         */
        "fullWidth"?: string;
        "label"?: string;
        "maxlength"?: number;
        "name"?: string;
        "onIfxInput"?: (event: IfxTextareaCustomEvent<string>) => void;
        "placeholder"?: string;
        /**
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * @default false
         */
        "required"?: boolean;
        /**
          * @default "both"
         */
        "resize"?: "both" | "horizontal" | "vertical" | "none";
        "rows"?: number;
        "value"?: string;
        /**
          * @default "soft"
         */
        "wrap"?: "hard" | "soft" | "off";
    }
    interface IfxTooltip {
        /**
          * @default false
         */
        "appendToBody"?: boolean;
        "ariaLabel"?: string | null;
        /**
          * @default ''
         */
        "header"?: string;
        "icon"?: string;
        /**
          * @default 'auto'
         */
        "position"?: 'bottom-start' | 'top-start' | 'left' | 'bottom-end' | 'top-end' | 'right' | 'bottom' | 'top' | 'auto';
        /**
          * @default ''
         */
        "text"?: string;
        /**
          * @default 'compact'
         */
        "variant"?: 'compact' | 'dismissible' | 'extended';
    }
    interface IfxTreeView {
        "ariaLabel"?: string | null;
        /**
          * @default false
         */
        "disableAllItems"?: boolean;
        /**
          * @default false
         */
        "expandAllItems"?: boolean;
        "label"?: string;
        "onIfxTreeViewDisableAllChange"?: (event: IfxTreeViewCustomEvent<boolean>) => void;
        "onIfxTreeViewExpandAllChange"?: (event: IfxTreeViewCustomEvent<boolean>) => void;
    }
    interface IfxTreeViewItem {
        "ariaLabel"?: string | null;
        /**
          * @default false
         */
        "disableItem"?: boolean;
        /**
          * @default false
         */
        "expanded"?: boolean;
        /**
          * @default false
         */
        "initiallyExpanded"?: boolean;
        /**
          * @default false
         */
        "initiallySelected"?: boolean;
        "onIfxTreeViewItemCheckChange"?: (event: IfxTreeViewItemCustomEvent<TreeViewCheckChangeEvent>) => void;
        "onIfxTreeViewItemDisableChange"?: (event: IfxTreeViewItemCustomEvent<TreeViewDisableChangeEvent>) => void;
        "onIfxTreeViewItemExpandChange"?: (event: IfxTreeViewItemCustomEvent<TreeViewExpandChangeEvent>) => void;
        "value"?: string;
    }

    interface IfxAccordionAttributes {
        "autoCollapse": boolean;
    }
    interface IfxAccordionItemAttributes {
        "caption": string;
        "open": boolean;
        "AriaLevel": 3;
    }
    interface IfxActionListAttributes {
        "listAriaLabel": string;
    }
    interface IfxActionListItemAttributes {
        "itemTitle": string;
        "description": string;
        "value": string;
        "href": string;
        "target": string;
        "disabled": boolean;
        "itemAriaLabel": string;
    }
    interface IfxAiLabelAttributes {
        "divider": boolean;
        "variant": 'label' | 'icon';
    }
    interface IfxAlertAttributes {
        "variant": "primary" | "success" | "danger" | "warning" | "info";
        "icon": string;
        "closable": boolean;
        "AriaLive": "assertive";
    }
    interface IfxBasicTableAttributes {
        "cols": any[] | string;
        "rows": any[] | string;
        "rowHeight": string;
        "tableHeight": string;
        "variant": string;
    }
    interface IfxBreadcrumbItemLabelAttributes {
        "icon": string;
        "href": string;
        "target": string;
    }
    interface IfxButtonAttributes {
        "variant": "primary" | "secondary" | "tertiary";
        "theme": "default" | "danger" | "inverse";
        "size": string;
        "disabled": boolean;
        "href": string;
        "target": string;
        "type": "button" | "submit" | "reset";
        "fullWidth": boolean;
        "ariaLabel": string | null;
    }
    interface IfxCardAttributes {
        "direction": "horizontal" | "vertical";
        "href": string;
        "target": string;
        "ariaLabel": string | null;
    }
    interface IfxCardImageAttributes {
        "src": string;
        "alt": string;
        "position": string;
    }
    interface IfxCheckboxAttributes {
        "disabled": boolean;
        "checked": boolean;
        "indeterminate": boolean;
        "error": boolean;
        "size": string;
        "value": string;
    }
    interface IfxCheckboxGroupAttributes {
        "alignment": "horizontal" | "vertical";
        "size": string;
        "showGroupLabel": boolean;
        "groupLabelText": string;
        "showCaption": boolean;
        "captionText": string;
        "showCaptionIcon": boolean;
        "required": boolean;
    }
    interface IfxChipAttributes {
        "placeholder": string;
        "size": "small" | "medium" | "large";
        "value": Array<string> | string;
        "variant": "single" | "multi";
        "theme": "outlined" | "filled-light" | "filled-dark";
        "readOnly": boolean;
        "ariaLabel": string | null;
        "disabled": boolean;
        "icon": string;
    }
    interface IfxChipItemAttributes {
        "value": string;
        "selected": boolean;
    }
    interface IfxContentSwitcherItemAttributes {
        "selected": boolean;
        "value": string;
    }
    interface IfxDatePickerAttributes {
        "size": string;
        "error": boolean;
        "success": boolean;
        "disabled": boolean;
        "ariaLabelText": string | null;
        "value": string;
        "type": string;
        "max": string;
        "min": string;
        "required": boolean;
        "label": string;
        "caption": string;
        "autocomplete": string;
    }
    interface IfxDownloadAttributes {
        "tokens": "css" | "scss";
    }
    interface IfxDropdownAttributes {
        "placement": Placement;
        "defaultOpen": boolean;
        "noAppendToBody": boolean;
        "disabled": boolean;
        "noCloseOnOutsideClick": boolean;
        "noCloseOnMenuClick": boolean;
    }
    interface IfxDropdownItemAttributes {
        "icon": string;
        "href": string;
        "target": string;
        "hide": boolean;
        "error": boolean;
    }
    interface IfxDropdownMenuAttributes {
        "isOpen": boolean;
        "size": string;
    }
    interface IfxDropdownTriggerAttributes {
        "isOpen": boolean;
    }
    interface IfxDropdownTriggerButtonAttributes {
        "isOpen": boolean;
        "theme": "default" | "danger" | "inverse";
        "variant": "primary";
        "size": "s" | "m";
        "disabled": boolean;
        "hideArrow": boolean;
    }
    interface IfxFileUploadAttributes {
        "dragAndDrop": boolean;
        "required": boolean;
        "disabled": boolean;
        "maxFileSizeMB": number;
        "allowedFileTypes": string | string[];
        "additionalAllowedFileTypes": string | string[];
        "allowAnyFileType": boolean;
        "allowedFileExtensions": string | string[];
        "maxFiles": number | undefined;
        "label": string;
        "labelRequiredError": string;
        "labelBrowseFiles": string;
        "labelDragAndDrop": string;
        "labelUploadedFilesHeading": string;
        "labelFileTooLarge": string;
        "labelUnsupportedFileType": string;
        "labelUploaded": string;
        "labelUploadFailed": string;
        "labelSupportedFormatsTemplate": string;
        "labelFileSingular": string;
        "labelFilePlural": string;
        "labelMaxFilesInfo": string;
        "labelMaxFilesExceeded": string;
        "ariaLabelBrowseFiles": string;
        "ariaLabelDropzone": string;
        "ariaLabelFileInput": string;
        "ariaLabelRemoveFile": string;
        "ariaLabelCancelUpload": string;
        "ariaLabelRetryUpload": string;
        "ariaLabelUploadingStatus": string;
        "ariaLabelUploadedStatus": string;
        "ariaLabelUploadFailedStatus": string;
    }
    interface IfxFilterAccordionAttributes {
        "maxVisibleItems": number;
        "filterGroupName": "";
    }
    interface IfxFilterBarAttributes {
        "maxShownFilters": number;
        "showMoreFiltersButton": boolean;
    }
    interface IfxFilterSearchAttributes {
        "filterName": string;
        "disabled": boolean;
        "filterValue": string;
        "filterKey": string;
        "filterOrientation": string;
        "placeholder": string;
    }
    interface IfxFooterAttributes {
        "copyrightText": string;
    }
    interface IfxIconAttributes {
        "icon": string;
        "ifxIcon": string;
    }
    interface IfxIconButtonAttributes {
        "variant": "primary" | "secondary" | "tertiary";
        "size": string;
        "disabled": boolean;
        "icon": string;
        "href": string;
        "target": string;
        "shape": string;
        "ariaLabel": string | null;
    }
    interface IfxIndicatorAttributes {
        "inverted": boolean;
        "ariaLabel": string | null;
        "variant": string;
        "number": number;
    }
    interface IfxLinkAttributes {
        "href": string;
        "target": string;
        "variant": string;
        "size": string;
        "disabled": boolean;
        "download": string;
        "ariaLabel": string | null;
    }
    interface IfxListAttributes {
        "name": "";
        "maxVisibleItems": 6;
        "type": string;
        "resetTrigger": boolean;
    }
    interface IfxListEntryAttributes {
        "value": boolean;
        "label": string;
        "type": string;
    }
    interface IfxModalAttributes {
        "opened": boolean;
        "caption": string;
        "captionAriaLabel": string | null;
        "closeOnOverlayClick": boolean;
        "variant": "default" | "alert-brand" | "alert-danger";
        "size": "s" | "m" | "l";
        "alertIcon": string;
        "okButtonLabel": string;
        "cancelButtonLabel": string;
        "closeButtonAriaLabel": string | null;
        "showCloseButton": boolean;
    }
    interface IfxMultiselectAttributes {
        "name": string;
        "disabled": boolean;
        "required": boolean;
        "error": boolean;
        "caption": string;
        "label": string;
        "placeholder": string;
        "showSearch": boolean;
        "showSelectAll": boolean;
        "showClearButton": boolean;
        "showExpandCollapse": boolean;
        "noResultsMessage": string;
        "showNoResultsMessage": boolean;
        "searchPlaceholder": string;
        "selectAllLabel": string;
        "expandLabel": string;
        "collapseLabel": string;
        "ariaMultiSelectLabel": string;
        "ariaMultiSelectLabelledBy": string;
        "ariaMultiSelectDescribedBy": string;
        "ariaSearchLabel": string;
        "ariaClearLabel": string;
        "ariaToggleLabel": string;
        "ariaSelectAllLabel": string;
        "ariaExpandAllLabel": string;
        "ariaCollapseAllLabel": string;
    }
    interface IfxMultiselectOptionAttributes {
        "value": string;
        "selected": boolean;
        "disabled": boolean;
        "indeterminate": boolean;
    }
    interface IfxNavbarAttributes {
        "applicationName": string;
        "fixed": boolean;
        "showLogoAndAppname": boolean;
        "logoHref": string;
        "logoHrefTarget": string;
    }
    interface IfxNavbarItemAttributes {
        "showLabel": boolean;
        "icon": string;
        "href": string;
        "target": string;
        "hideOnMobile": boolean;
        "numberIndicator": number;
        "dotIndicator": boolean;
    }
    interface IfxNavbarProfileAttributes {
        "showLabel": boolean;
        "href": string;
        "imageUrl": string;
        "target": string;
        "alt": string;
        "userName": string;
    }
    interface IfxNotificationAttributes {
        "icon": string;
        "variant": NotificationVariant;
        "linkText": string;
        "linkHref": string;
        "linkTarget": string;
    }
    interface IfxPaginationAttributes {
        "currentPage": number;
        "showItemsPerPage": boolean;
        "total": number;
        "itemsPerPage": any[] | string;
    }
    interface IfxPopoverAttributes {
        "popoverTitle": string;
        "text": string;
        "position": 'bottom-start' | 'top-start' | 'left' | 'bottom-end' | 'top-end' | 'right' | 'bottom' | 'top' | 'auto';
        "disabled": boolean;
        "open": boolean;
        "ariaLabel": string | null;
    }
    interface IfxProgressBarAttributes {
        "value": number;
        "size": string;
        "showLabel": boolean;
    }
    interface IfxRadioButtonAttributes {
        "disabled": boolean;
        "value": string;
        "error": boolean;
        "size": "s" | "m";
        "name": string;
        "checked": boolean;
    }
    interface IfxRadioButtonGroupAttributes {
        "alignment": "horizontal" | "vertical";
        "size": string;
        "showGroupLabel": boolean;
        "groupLabelText": string;
        "showCaption": boolean;
        "captionText": string;
        "showCaptionIcon": boolean;
        "required": boolean;
    }
    interface IfxSearchBarAttributes {
        "isOpen": boolean;
        "disabled": boolean;
        "value": string;
        "maxlength": number;
        "autocomplete": string;
    }
    interface IfxSearchFieldAttributes {
        "value": string;
        "showSuggestions": boolean;
        "maxSuggestions": number;
        "maxHistoryItems": number;
        "enableHistory": boolean;
        "historyKey": string;
        "historyHeaderText": string;
        "ariaLabel": string | null;
        "ariaLabelledBy": string | null;
        "ariaDescribedBy": string | null;
        "deleteIconAriaLabel": string;
        "historyDeleteAriaLabel": string;
        "dropdownAriaLabel": string;
        "suggestionAriaLabel": string;
        "historyItemAriaLabel": string;
        "showDeleteIcon": boolean;
        "disabled": boolean;
        "size": string;
        "placeholder": string;
        "autocomplete": string;
        "maxlength": number;
    }
    interface IfxSegmentAttributes {
        "icon": string;
        "segmentIndex": number;
        "selected": boolean;
        "value": string;
    }
    interface IfxSegmentedControlAttributes {
        "caption": string;
        "label": string;
        "size": "regular" | "small";
        "required": boolean;
        "error": boolean;
    }
    interface IfxSelectAttributes {
        "value": string;
        "name": string;
        "choices": Array<any> | string;
        "renderChoiceLimit": number;
        "maxItemCount": number;
        "addItems": boolean;
        "removeItems": boolean;
        "removeItemButton": boolean;
        "editItems": boolean;
        "duplicateItemsAllowed": boolean;
        "delimiter": string;
        "paste": boolean;
        "showSearch": boolean;
        "searchChoices": boolean;
        "searchFields": Array<string> | string;
        "searchFloor": number;
        "searchResultLimit": number;
        "position": 'auto' | 'top' | 'bottom';
        "resetScrollPosition": boolean;
        "shouldSort": boolean;
        "shouldSortItems": boolean;
        "placeholder": string;
        "searchPlaceholderValue": string;
        "prependValue": string;
        "appendValue": string;
        "renderSelectedChoices": 'always' | 'auto';
        "loadingText": string;
        "noResultsText": string | NoResultsTextFn;
        "noChoicesText": string | NoChoicesTextFn;
        "itemSelectText": '';
        "addItemText": string | AddItemTextFn;
        "maxItemText": string | MaxItemTextFn;
        "uniqueItemText": UniqueItemText;
        "addItemFilter": string | RegExp | ItemFilterFn;
        "customAddItemText": CustomAddItemText;
        "error": boolean;
        "label": string;
        "caption": string;
        "disabled": boolean;
        "required": boolean;
        "placeholderValue": string;
        "options": any[] | string;
        "size": string;
        "showClearButton": boolean;
    }
    interface IfxSetFilterAttributes {
        "filterName": string;
        "filterLabel": string;
        "placeholder": string;
        "type": "text" | "single-select" | "multi-select";
        "options": any[] | string;
    }
    interface IfxSidebarAttributes {
        "applicationName": string;
        "initialCollapse": boolean;
        "showFooter": boolean;
        "showHeader": boolean;
        "termsOfUse": string;
        "imprint": string;
        "privacyPolicy": string;
        "target": string;
        "copyrightText": string;
        "collapsible": boolean;
        "collapsed": boolean;
        "hideMenuLabel": string;
    }
    interface IfxSidebarItemAttributes {
        "icon": string;
        "href": string;
        "target": string;
        "numberIndicator": number;
        "active": boolean;
        "isActionItem": boolean;
    }
    interface IfxSidebarTitleAttributes {
        "showInCollapsed": boolean;
    }
    interface IfxSliderAttributes {
        "min": number;
        "max": number;
        "step": number;
        "value": number;
        "minValueHandle": number;
        "maxValueHandle": number;
        "disabled": boolean;
        "showPercentage": boolean;
        "leftIcon": string;
        "rightIcon": string;
        "leftText": string;
        "rightText": string;
        "type": "single" | "double";
        "ariaLabel": string | null;
    }
    interface IfxSpinnerAttributes {
        "size": string;
        "variant": string;
        "inverted": boolean;
        "ariaLabel": string | null;
    }
    interface IfxStatusAttributes {
        "label": string;
        "border": boolean;
        "color": string;
    }
    interface IfxStepAttributes {
        "complete": boolean;
        "disabled": boolean;
        "error": boolean;
        "lastStep": boolean;
        "stepId": number;
    }
    interface IfxStepperAttributes {
        "activeStep": number;
        "indicatorPosition": "left" | "right";
        "showStepNumber": boolean;
        "variant": "default" | "compact" | "vertical";
        "ariaLabel": string | null;
        "ariaCurrent": string | null;
    }
    interface IfxSwitchAttributes {
        "checked": boolean;
        "disabled": boolean;
        "name": string;
        "value": string;
    }
    interface IfxTabAttributes {
        "header": string;
        "disabled": boolean;
        "icon": string;
        "iconPosition": "left" | "right";
    }
    interface IfxTableAttributes {
        "cols": string;
        "rows": string;
        "rowHeight": string;
        "tableHeight": string;
        "pagination": boolean;
        "paginationItemsPerPage": string;
        "filterOrientation": string;
        "headline": string;
        "headlineNumber": number;
        "variant": string;
        "serverSidePagination": boolean;
        "enableSelection": boolean;
        "showLoading": boolean;
        "fitColumns": boolean;
        "columnMinWidth": number;
        "columnWidth": string;
    }
    interface IfxTabsAttributes {
        "orientation": string;
        "activeTabIndex": number;
        "fullWidth": boolean;
    }
    interface IfxTemplateAttributes {
        "name": string;
        "thumbnail": string;
    }
    interface IfxTextFieldAttributes {
        "placeholder": string;
        "value": string;
        "error": boolean;
        "label": string;
        "icon": string;
        "caption": string;
        "size": string;
        "required": boolean;
        "success": boolean;
        "disabled": boolean;
        "readOnly": boolean;
        "maxlength": number;
        "showDeleteIcon": boolean;
        "autocomplete": string;
        "type": "text" | "password";
        "internalId": string;
    }
    interface IfxTextareaAttributes {
        "caption": string;
        "cols": number;
        "disabled": boolean;
        "error": boolean;
        "label": string;
        "maxlength": number;
        "name": string;
        "placeholder": string;
        "required": boolean;
        "readOnly": boolean;
        "resize": "both" | "horizontal" | "vertical" | "none";
        "rows": number;
        "value": string;
        "wrap": "hard" | "soft" | "off";
        "fullWidth": string;
    }
    interface IfxTooltipAttributes {
        "header": string;
        "text": string;
        "position": 'bottom-start' | 'top-start' | 'left' | 'bottom-end' | 'top-end' | 'right' | 'bottom' | 'top' | 'auto';
        "ariaLabel": string | null;
        "variant": 'compact' | 'dismissible' | 'extended';
        "icon": string;
        "appendToBody": boolean;
    }
    interface IfxTreeViewAttributes {
        "label": string;
        "disableAllItems": boolean;
        "expandAllItems": boolean;
        "ariaLabel": string | null;
    }
    interface IfxTreeViewItemAttributes {
        "expanded": boolean;
        "initiallyExpanded": boolean;
        "disableItem": boolean;
        "ariaLabel": string | null;
        "initiallySelected": boolean;
        "value": string;
    }

    interface IntrinsicElements {
        "ifx-accordion": Omit<IfxAccordion, keyof IfxAccordionAttributes> & { [K in keyof IfxAccordion & keyof IfxAccordionAttributes]?: IfxAccordion[K] } & { [K in keyof IfxAccordion & keyof IfxAccordionAttributes as `attr:${K}`]?: IfxAccordionAttributes[K] } & { [K in keyof IfxAccordion & keyof IfxAccordionAttributes as `prop:${K}`]?: IfxAccordion[K] };
        "ifx-accordion-item": Omit<IfxAccordionItem, keyof IfxAccordionItemAttributes> & { [K in keyof IfxAccordionItem & keyof IfxAccordionItemAttributes]?: IfxAccordionItem[K] } & { [K in keyof IfxAccordionItem & keyof IfxAccordionItemAttributes as `attr:${K}`]?: IfxAccordionItemAttributes[K] } & { [K in keyof IfxAccordionItem & keyof IfxAccordionItemAttributes as `prop:${K}`]?: IfxAccordionItem[K] };
        "ifx-action-list": Omit<IfxActionList, keyof IfxActionListAttributes> & { [K in keyof IfxActionList & keyof IfxActionListAttributes]?: IfxActionList[K] } & { [K in keyof IfxActionList & keyof IfxActionListAttributes as `attr:${K}`]?: IfxActionListAttributes[K] } & { [K in keyof IfxActionList & keyof IfxActionListAttributes as `prop:${K}`]?: IfxActionList[K] };
        "ifx-action-list-item": Omit<IfxActionListItem, keyof IfxActionListItemAttributes> & { [K in keyof IfxActionListItem & keyof IfxActionListItemAttributes]?: IfxActionListItem[K] } & { [K in keyof IfxActionListItem & keyof IfxActionListItemAttributes as `attr:${K}`]?: IfxActionListItemAttributes[K] } & { [K in keyof IfxActionListItem & keyof IfxActionListItemAttributes as `prop:${K}`]?: IfxActionListItem[K] };
        "ifx-ai-label": Omit<IfxAiLabel, keyof IfxAiLabelAttributes> & { [K in keyof IfxAiLabel & keyof IfxAiLabelAttributes]?: IfxAiLabel[K] } & { [K in keyof IfxAiLabel & keyof IfxAiLabelAttributes as `attr:${K}`]?: IfxAiLabelAttributes[K] } & { [K in keyof IfxAiLabel & keyof IfxAiLabelAttributes as `prop:${K}`]?: IfxAiLabel[K] };
        "ifx-alert": Omit<IfxAlert, keyof IfxAlertAttributes> & { [K in keyof IfxAlert & keyof IfxAlertAttributes]?: IfxAlert[K] } & { [K in keyof IfxAlert & keyof IfxAlertAttributes as `attr:${K}`]?: IfxAlertAttributes[K] } & { [K in keyof IfxAlert & keyof IfxAlertAttributes as `prop:${K}`]?: IfxAlert[K] };
        "ifx-basic-table": Omit<IfxBasicTable, keyof IfxBasicTableAttributes> & { [K in keyof IfxBasicTable & keyof IfxBasicTableAttributes]?: IfxBasicTable[K] } & { [K in keyof IfxBasicTable & keyof IfxBasicTableAttributes as `attr:${K}`]?: IfxBasicTableAttributes[K] } & { [K in keyof IfxBasicTable & keyof IfxBasicTableAttributes as `prop:${K}`]?: IfxBasicTable[K] };
        "ifx-breadcrumb": IfxBreadcrumb;
        "ifx-breadcrumb-item": IfxBreadcrumbItem;
        "ifx-breadcrumb-item-label": Omit<IfxBreadcrumbItemLabel, keyof IfxBreadcrumbItemLabelAttributes> & { [K in keyof IfxBreadcrumbItemLabel & keyof IfxBreadcrumbItemLabelAttributes]?: IfxBreadcrumbItemLabel[K] } & { [K in keyof IfxBreadcrumbItemLabel & keyof IfxBreadcrumbItemLabelAttributes as `attr:${K}`]?: IfxBreadcrumbItemLabelAttributes[K] } & { [K in keyof IfxBreadcrumbItemLabel & keyof IfxBreadcrumbItemLabelAttributes as `prop:${K}`]?: IfxBreadcrumbItemLabel[K] };
        "ifx-button": Omit<IfxButton, keyof IfxButtonAttributes> & { [K in keyof IfxButton & keyof IfxButtonAttributes]?: IfxButton[K] } & { [K in keyof IfxButton & keyof IfxButtonAttributes as `attr:${K}`]?: IfxButtonAttributes[K] } & { [K in keyof IfxButton & keyof IfxButtonAttributes as `prop:${K}`]?: IfxButton[K] };
        "ifx-card": Omit<IfxCard, keyof IfxCardAttributes> & { [K in keyof IfxCard & keyof IfxCardAttributes]?: IfxCard[K] } & { [K in keyof IfxCard & keyof IfxCardAttributes as `attr:${K}`]?: IfxCardAttributes[K] } & { [K in keyof IfxCard & keyof IfxCardAttributes as `prop:${K}`]?: IfxCard[K] };
        "ifx-card-headline": IfxCardHeadline;
        "ifx-card-image": Omit<IfxCardImage, keyof IfxCardImageAttributes> & { [K in keyof IfxCardImage & keyof IfxCardImageAttributes]?: IfxCardImage[K] } & { [K in keyof IfxCardImage & keyof IfxCardImageAttributes as `attr:${K}`]?: IfxCardImageAttributes[K] } & { [K in keyof IfxCardImage & keyof IfxCardImageAttributes as `prop:${K}`]?: IfxCardImage[K] };
        "ifx-card-links": IfxCardLinks;
        "ifx-card-overline": IfxCardOverline;
        "ifx-card-text": IfxCardText;
        "ifx-checkbox": Omit<IfxCheckbox, keyof IfxCheckboxAttributes> & { [K in keyof IfxCheckbox & keyof IfxCheckboxAttributes]?: IfxCheckbox[K] } & { [K in keyof IfxCheckbox & keyof IfxCheckboxAttributes as `attr:${K}`]?: IfxCheckboxAttributes[K] } & { [K in keyof IfxCheckbox & keyof IfxCheckboxAttributes as `prop:${K}`]?: IfxCheckbox[K] };
        "ifx-checkbox-group": Omit<IfxCheckboxGroup, keyof IfxCheckboxGroupAttributes> & { [K in keyof IfxCheckboxGroup & keyof IfxCheckboxGroupAttributes]?: IfxCheckboxGroup[K] } & { [K in keyof IfxCheckboxGroup & keyof IfxCheckboxGroupAttributes as `attr:${K}`]?: IfxCheckboxGroupAttributes[K] } & { [K in keyof IfxCheckboxGroup & keyof IfxCheckboxGroupAttributes as `prop:${K}`]?: IfxCheckboxGroup[K] };
        "ifx-chip": Omit<IfxChip, keyof IfxChipAttributes> & { [K in keyof IfxChip & keyof IfxChipAttributes]?: IfxChip[K] } & { [K in keyof IfxChip & keyof IfxChipAttributes as `attr:${K}`]?: IfxChipAttributes[K] } & { [K in keyof IfxChip & keyof IfxChipAttributes as `prop:${K}`]?: IfxChip[K] };
        "ifx-chip-item": Omit<IfxChipItem, keyof IfxChipItemAttributes> & { [K in keyof IfxChipItem & keyof IfxChipItemAttributes]?: IfxChipItem[K] } & { [K in keyof IfxChipItem & keyof IfxChipItemAttributes as `attr:${K}`]?: IfxChipItemAttributes[K] } & { [K in keyof IfxChipItem & keyof IfxChipItemAttributes as `prop:${K}`]?: IfxChipItem[K] };
        "ifx-content-switcher": IfxContentSwitcher;
        "ifx-content-switcher-item": Omit<IfxContentSwitcherItem, keyof IfxContentSwitcherItemAttributes> & { [K in keyof IfxContentSwitcherItem & keyof IfxContentSwitcherItemAttributes]?: IfxContentSwitcherItem[K] } & { [K in keyof IfxContentSwitcherItem & keyof IfxContentSwitcherItemAttributes as `attr:${K}`]?: IfxContentSwitcherItemAttributes[K] } & { [K in keyof IfxContentSwitcherItem & keyof IfxContentSwitcherItemAttributes as `prop:${K}`]?: IfxContentSwitcherItem[K] };
        "ifx-date-picker": Omit<IfxDatePicker, keyof IfxDatePickerAttributes> & { [K in keyof IfxDatePicker & keyof IfxDatePickerAttributes]?: IfxDatePicker[K] } & { [K in keyof IfxDatePicker & keyof IfxDatePickerAttributes as `attr:${K}`]?: IfxDatePickerAttributes[K] } & { [K in keyof IfxDatePicker & keyof IfxDatePickerAttributes as `prop:${K}`]?: IfxDatePicker[K] };
        "ifx-download": Omit<IfxDownload, keyof IfxDownloadAttributes> & { [K in keyof IfxDownload & keyof IfxDownloadAttributes]?: IfxDownload[K] } & { [K in keyof IfxDownload & keyof IfxDownloadAttributes as `attr:${K}`]?: IfxDownloadAttributes[K] } & { [K in keyof IfxDownload & keyof IfxDownloadAttributes as `prop:${K}`]?: IfxDownload[K] };
        "ifx-dropdown": Omit<IfxDropdown, keyof IfxDropdownAttributes> & { [K in keyof IfxDropdown & keyof IfxDropdownAttributes]?: IfxDropdown[K] } & { [K in keyof IfxDropdown & keyof IfxDropdownAttributes as `attr:${K}`]?: IfxDropdownAttributes[K] } & { [K in keyof IfxDropdown & keyof IfxDropdownAttributes as `prop:${K}`]?: IfxDropdown[K] };
        "ifx-dropdown-header": IfxDropdownHeader;
        "ifx-dropdown-item": Omit<IfxDropdownItem, keyof IfxDropdownItemAttributes> & { [K in keyof IfxDropdownItem & keyof IfxDropdownItemAttributes]?: IfxDropdownItem[K] } & { [K in keyof IfxDropdownItem & keyof IfxDropdownItemAttributes as `attr:${K}`]?: IfxDropdownItemAttributes[K] } & { [K in keyof IfxDropdownItem & keyof IfxDropdownItemAttributes as `prop:${K}`]?: IfxDropdownItem[K] };
        "ifx-dropdown-menu": Omit<IfxDropdownMenu, keyof IfxDropdownMenuAttributes> & { [K in keyof IfxDropdownMenu & keyof IfxDropdownMenuAttributes]?: IfxDropdownMenu[K] } & { [K in keyof IfxDropdownMenu & keyof IfxDropdownMenuAttributes as `attr:${K}`]?: IfxDropdownMenuAttributes[K] } & { [K in keyof IfxDropdownMenu & keyof IfxDropdownMenuAttributes as `prop:${K}`]?: IfxDropdownMenu[K] };
        "ifx-dropdown-separator": IfxDropdownSeparator;
        "ifx-dropdown-trigger": Omit<IfxDropdownTrigger, keyof IfxDropdownTriggerAttributes> & { [K in keyof IfxDropdownTrigger & keyof IfxDropdownTriggerAttributes]?: IfxDropdownTrigger[K] } & { [K in keyof IfxDropdownTrigger & keyof IfxDropdownTriggerAttributes as `attr:${K}`]?: IfxDropdownTriggerAttributes[K] } & { [K in keyof IfxDropdownTrigger & keyof IfxDropdownTriggerAttributes as `prop:${K}`]?: IfxDropdownTrigger[K] };
        "ifx-dropdown-trigger-button": Omit<IfxDropdownTriggerButton, keyof IfxDropdownTriggerButtonAttributes> & { [K in keyof IfxDropdownTriggerButton & keyof IfxDropdownTriggerButtonAttributes]?: IfxDropdownTriggerButton[K] } & { [K in keyof IfxDropdownTriggerButton & keyof IfxDropdownTriggerButtonAttributes as `attr:${K}`]?: IfxDropdownTriggerButtonAttributes[K] } & { [K in keyof IfxDropdownTriggerButton & keyof IfxDropdownTriggerButtonAttributes as `prop:${K}`]?: IfxDropdownTriggerButton[K] };
        "ifx-faq": IfxFaq;
        "ifx-file-upload": Omit<IfxFileUpload, keyof IfxFileUploadAttributes> & { [K in keyof IfxFileUpload & keyof IfxFileUploadAttributes]?: IfxFileUpload[K] } & { [K in keyof IfxFileUpload & keyof IfxFileUploadAttributes as `attr:${K}`]?: IfxFileUploadAttributes[K] } & { [K in keyof IfxFileUpload & keyof IfxFileUploadAttributes as `prop:${K}`]?: IfxFileUpload[K] };
        "ifx-filter-accordion": Omit<IfxFilterAccordion, keyof IfxFilterAccordionAttributes> & { [K in keyof IfxFilterAccordion & keyof IfxFilterAccordionAttributes]?: IfxFilterAccordion[K] } & { [K in keyof IfxFilterAccordion & keyof IfxFilterAccordionAttributes as `attr:${K}`]?: IfxFilterAccordionAttributes[K] } & { [K in keyof IfxFilterAccordion & keyof IfxFilterAccordionAttributes as `prop:${K}`]?: IfxFilterAccordion[K] };
        "ifx-filter-bar": Omit<IfxFilterBar, keyof IfxFilterBarAttributes> & { [K in keyof IfxFilterBar & keyof IfxFilterBarAttributes]?: IfxFilterBar[K] } & { [K in keyof IfxFilterBar & keyof IfxFilterBarAttributes as `attr:${K}`]?: IfxFilterBarAttributes[K] } & { [K in keyof IfxFilterBar & keyof IfxFilterBarAttributes as `prop:${K}`]?: IfxFilterBar[K] };
        "ifx-filter-search": Omit<IfxFilterSearch, keyof IfxFilterSearchAttributes> & { [K in keyof IfxFilterSearch & keyof IfxFilterSearchAttributes]?: IfxFilterSearch[K] } & { [K in keyof IfxFilterSearch & keyof IfxFilterSearchAttributes as `attr:${K}`]?: IfxFilterSearchAttributes[K] } & { [K in keyof IfxFilterSearch & keyof IfxFilterSearchAttributes as `prop:${K}`]?: IfxFilterSearch[K] };
        "ifx-filter-type-group": IfxFilterTypeGroup;
        "ifx-footer": Omit<IfxFooter, keyof IfxFooterAttributes> & { [K in keyof IfxFooter & keyof IfxFooterAttributes]?: IfxFooter[K] } & { [K in keyof IfxFooter & keyof IfxFooterAttributes as `attr:${K}`]?: IfxFooterAttributes[K] } & { [K in keyof IfxFooter & keyof IfxFooterAttributes as `prop:${K}`]?: IfxFooter[K] };
        "ifx-footer-column": IfxFooterColumn;
        "ifx-icon": Omit<IfxIcon, keyof IfxIconAttributes> & { [K in keyof IfxIcon & keyof IfxIconAttributes]?: IfxIcon[K] } & { [K in keyof IfxIcon & keyof IfxIconAttributes as `attr:${K}`]?: IfxIconAttributes[K] } & { [K in keyof IfxIcon & keyof IfxIconAttributes as `prop:${K}`]?: IfxIcon[K] };
        "ifx-icon-button": Omit<IfxIconButton, keyof IfxIconButtonAttributes> & { [K in keyof IfxIconButton & keyof IfxIconButtonAttributes]?: IfxIconButton[K] } & { [K in keyof IfxIconButton & keyof IfxIconButtonAttributes as `attr:${K}`]?: IfxIconButtonAttributes[K] } & { [K in keyof IfxIconButton & keyof IfxIconButtonAttributes as `prop:${K}`]?: IfxIconButton[K] };
        "ifx-icons-preview": IfxIconsPreview;
        "ifx-indicator": Omit<IfxIndicator, keyof IfxIndicatorAttributes> & { [K in keyof IfxIndicator & keyof IfxIndicatorAttributes]?: IfxIndicator[K] } & { [K in keyof IfxIndicator & keyof IfxIndicatorAttributes as `attr:${K}`]?: IfxIndicatorAttributes[K] } & { [K in keyof IfxIndicator & keyof IfxIndicatorAttributes as `prop:${K}`]?: IfxIndicator[K] };
        "ifx-link": Omit<IfxLink, keyof IfxLinkAttributes> & { [K in keyof IfxLink & keyof IfxLinkAttributes]?: IfxLink[K] } & { [K in keyof IfxLink & keyof IfxLinkAttributes as `attr:${K}`]?: IfxLinkAttributes[K] } & { [K in keyof IfxLink & keyof IfxLinkAttributes as `prop:${K}`]?: IfxLink[K] };
        "ifx-list": Omit<IfxList, keyof IfxListAttributes> & { [K in keyof IfxList & keyof IfxListAttributes]?: IfxList[K] } & { [K in keyof IfxList & keyof IfxListAttributes as `attr:${K}`]?: IfxListAttributes[K] } & { [K in keyof IfxList & keyof IfxListAttributes as `prop:${K}`]?: IfxList[K] };
        "ifx-list-entry": Omit<IfxListEntry, keyof IfxListEntryAttributes> & { [K in keyof IfxListEntry & keyof IfxListEntryAttributes]?: IfxListEntry[K] } & { [K in keyof IfxListEntry & keyof IfxListEntryAttributes as `attr:${K}`]?: IfxListEntryAttributes[K] } & { [K in keyof IfxListEntry & keyof IfxListEntryAttributes as `prop:${K}`]?: IfxListEntry[K] };
        "ifx-modal": Omit<IfxModal, keyof IfxModalAttributes> & { [K in keyof IfxModal & keyof IfxModalAttributes]?: IfxModal[K] } & { [K in keyof IfxModal & keyof IfxModalAttributes as `attr:${K}`]?: IfxModalAttributes[K] } & { [K in keyof IfxModal & keyof IfxModalAttributes as `prop:${K}`]?: IfxModal[K] };
        "ifx-multiselect": Omit<IfxMultiselect, keyof IfxMultiselectAttributes> & { [K in keyof IfxMultiselect & keyof IfxMultiselectAttributes]?: IfxMultiselect[K] } & { [K in keyof IfxMultiselect & keyof IfxMultiselectAttributes as `attr:${K}`]?: IfxMultiselectAttributes[K] } & { [K in keyof IfxMultiselect & keyof IfxMultiselectAttributes as `prop:${K}`]?: IfxMultiselect[K] };
        "ifx-multiselect-option": Omit<IfxMultiselectOption, keyof IfxMultiselectOptionAttributes> & { [K in keyof IfxMultiselectOption & keyof IfxMultiselectOptionAttributes]?: IfxMultiselectOption[K] } & { [K in keyof IfxMultiselectOption & keyof IfxMultiselectOptionAttributes as `attr:${K}`]?: IfxMultiselectOptionAttributes[K] } & { [K in keyof IfxMultiselectOption & keyof IfxMultiselectOptionAttributes as `prop:${K}`]?: IfxMultiselectOption[K] };
        "ifx-navbar": Omit<IfxNavbar, keyof IfxNavbarAttributes> & { [K in keyof IfxNavbar & keyof IfxNavbarAttributes]?: IfxNavbar[K] } & { [K in keyof IfxNavbar & keyof IfxNavbarAttributes as `attr:${K}`]?: IfxNavbarAttributes[K] } & { [K in keyof IfxNavbar & keyof IfxNavbarAttributes as `prop:${K}`]?: IfxNavbar[K] };
        "ifx-navbar-item": Omit<IfxNavbarItem, keyof IfxNavbarItemAttributes> & { [K in keyof IfxNavbarItem & keyof IfxNavbarItemAttributes]?: IfxNavbarItem[K] } & { [K in keyof IfxNavbarItem & keyof IfxNavbarItemAttributes as `attr:${K}`]?: IfxNavbarItemAttributes[K] } & { [K in keyof IfxNavbarItem & keyof IfxNavbarItemAttributes as `prop:${K}`]?: IfxNavbarItem[K] };
        "ifx-navbar-profile": Omit<IfxNavbarProfile, keyof IfxNavbarProfileAttributes> & { [K in keyof IfxNavbarProfile & keyof IfxNavbarProfileAttributes]?: IfxNavbarProfile[K] } & { [K in keyof IfxNavbarProfile & keyof IfxNavbarProfileAttributes as `attr:${K}`]?: IfxNavbarProfileAttributes[K] } & { [K in keyof IfxNavbarProfile & keyof IfxNavbarProfileAttributes as `prop:${K}`]?: IfxNavbarProfile[K] };
        "ifx-notification": Omit<IfxNotification, keyof IfxNotificationAttributes> & { [K in keyof IfxNotification & keyof IfxNotificationAttributes]?: IfxNotification[K] } & { [K in keyof IfxNotification & keyof IfxNotificationAttributes as `attr:${K}`]?: IfxNotificationAttributes[K] } & { [K in keyof IfxNotification & keyof IfxNotificationAttributes as `prop:${K}`]?: IfxNotification[K] };
        "ifx-overview-table": IfxOverviewTable;
        "ifx-pagination": Omit<IfxPagination, keyof IfxPaginationAttributes> & { [K in keyof IfxPagination & keyof IfxPaginationAttributes]?: IfxPagination[K] } & { [K in keyof IfxPagination & keyof IfxPaginationAttributes as `attr:${K}`]?: IfxPaginationAttributes[K] } & { [K in keyof IfxPagination & keyof IfxPaginationAttributes as `prop:${K}`]?: IfxPagination[K] };
        "ifx-popover": Omit<IfxPopover, keyof IfxPopoverAttributes> & { [K in keyof IfxPopover & keyof IfxPopoverAttributes]?: IfxPopover[K] } & { [K in keyof IfxPopover & keyof IfxPopoverAttributes as `attr:${K}`]?: IfxPopoverAttributes[K] } & { [K in keyof IfxPopover & keyof IfxPopoverAttributes as `prop:${K}`]?: IfxPopover[K] };
        "ifx-progress-bar": Omit<IfxProgressBar, keyof IfxProgressBarAttributes> & { [K in keyof IfxProgressBar & keyof IfxProgressBarAttributes]?: IfxProgressBar[K] } & { [K in keyof IfxProgressBar & keyof IfxProgressBarAttributes as `attr:${K}`]?: IfxProgressBarAttributes[K] } & { [K in keyof IfxProgressBar & keyof IfxProgressBarAttributes as `prop:${K}`]?: IfxProgressBar[K] };
        "ifx-radio-button": Omit<IfxRadioButton, keyof IfxRadioButtonAttributes> & { [K in keyof IfxRadioButton & keyof IfxRadioButtonAttributes]?: IfxRadioButton[K] } & { [K in keyof IfxRadioButton & keyof IfxRadioButtonAttributes as `attr:${K}`]?: IfxRadioButtonAttributes[K] } & { [K in keyof IfxRadioButton & keyof IfxRadioButtonAttributes as `prop:${K}`]?: IfxRadioButton[K] };
        "ifx-radio-button-group": Omit<IfxRadioButtonGroup, keyof IfxRadioButtonGroupAttributes> & { [K in keyof IfxRadioButtonGroup & keyof IfxRadioButtonGroupAttributes]?: IfxRadioButtonGroup[K] } & { [K in keyof IfxRadioButtonGroup & keyof IfxRadioButtonGroupAttributes as `attr:${K}`]?: IfxRadioButtonGroupAttributes[K] } & { [K in keyof IfxRadioButtonGroup & keyof IfxRadioButtonGroupAttributes as `prop:${K}`]?: IfxRadioButtonGroup[K] };
        "ifx-search-bar": Omit<IfxSearchBar, keyof IfxSearchBarAttributes> & { [K in keyof IfxSearchBar & keyof IfxSearchBarAttributes]?: IfxSearchBar[K] } & { [K in keyof IfxSearchBar & keyof IfxSearchBarAttributes as `attr:${K}`]?: IfxSearchBarAttributes[K] } & { [K in keyof IfxSearchBar & keyof IfxSearchBarAttributes as `prop:${K}`]?: IfxSearchBar[K] };
        "ifx-search-field": Omit<IfxSearchField, keyof IfxSearchFieldAttributes> & { [K in keyof IfxSearchField & keyof IfxSearchFieldAttributes]?: IfxSearchField[K] } & { [K in keyof IfxSearchField & keyof IfxSearchFieldAttributes as `attr:${K}`]?: IfxSearchFieldAttributes[K] } & { [K in keyof IfxSearchField & keyof IfxSearchFieldAttributes as `prop:${K}`]?: IfxSearchField[K] };
        "ifx-segment": Omit<IfxSegment, keyof IfxSegmentAttributes> & { [K in keyof IfxSegment & keyof IfxSegmentAttributes]?: IfxSegment[K] } & { [K in keyof IfxSegment & keyof IfxSegmentAttributes as `attr:${K}`]?: IfxSegmentAttributes[K] } & { [K in keyof IfxSegment & keyof IfxSegmentAttributes as `prop:${K}`]?: IfxSegment[K] } & OneOf<"value", IfxSegment["value"], IfxSegmentAttributes["value"]>;
        "ifx-segmented-control": Omit<IfxSegmentedControl, keyof IfxSegmentedControlAttributes> & { [K in keyof IfxSegmentedControl & keyof IfxSegmentedControlAttributes]?: IfxSegmentedControl[K] } & { [K in keyof IfxSegmentedControl & keyof IfxSegmentedControlAttributes as `attr:${K}`]?: IfxSegmentedControlAttributes[K] } & { [K in keyof IfxSegmentedControl & keyof IfxSegmentedControlAttributes as `prop:${K}`]?: IfxSegmentedControl[K] };
        "ifx-select": Omit<IfxSelect, keyof IfxSelectAttributes> & { [K in keyof IfxSelect & keyof IfxSelectAttributes]?: IfxSelect[K] } & { [K in keyof IfxSelect & keyof IfxSelectAttributes as `attr:${K}`]?: IfxSelectAttributes[K] } & { [K in keyof IfxSelect & keyof IfxSelectAttributes as `prop:${K}`]?: IfxSelect[K] };
        "ifx-set-filter": Omit<IfxSetFilter, keyof IfxSetFilterAttributes> & { [K in keyof IfxSetFilter & keyof IfxSetFilterAttributes]?: IfxSetFilter[K] } & { [K in keyof IfxSetFilter & keyof IfxSetFilterAttributes as `attr:${K}`]?: IfxSetFilterAttributes[K] } & { [K in keyof IfxSetFilter & keyof IfxSetFilterAttributes as `prop:${K}`]?: IfxSetFilter[K] };
        "ifx-sidebar": Omit<IfxSidebar, keyof IfxSidebarAttributes> & { [K in keyof IfxSidebar & keyof IfxSidebarAttributes]?: IfxSidebar[K] } & { [K in keyof IfxSidebar & keyof IfxSidebarAttributes as `attr:${K}`]?: IfxSidebarAttributes[K] } & { [K in keyof IfxSidebar & keyof IfxSidebarAttributes as `prop:${K}`]?: IfxSidebar[K] };
        "ifx-sidebar-item": Omit<IfxSidebarItem, keyof IfxSidebarItemAttributes> & { [K in keyof IfxSidebarItem & keyof IfxSidebarItemAttributes]?: IfxSidebarItem[K] } & { [K in keyof IfxSidebarItem & keyof IfxSidebarItemAttributes as `attr:${K}`]?: IfxSidebarItemAttributes[K] } & { [K in keyof IfxSidebarItem & keyof IfxSidebarItemAttributes as `prop:${K}`]?: IfxSidebarItem[K] };
        "ifx-sidebar-title": Omit<IfxSidebarTitle, keyof IfxSidebarTitleAttributes> & { [K in keyof IfxSidebarTitle & keyof IfxSidebarTitleAttributes]?: IfxSidebarTitle[K] } & { [K in keyof IfxSidebarTitle & keyof IfxSidebarTitleAttributes as `attr:${K}`]?: IfxSidebarTitleAttributes[K] } & { [K in keyof IfxSidebarTitle & keyof IfxSidebarTitleAttributes as `prop:${K}`]?: IfxSidebarTitle[K] };
        "ifx-slider": Omit<IfxSlider, keyof IfxSliderAttributes> & { [K in keyof IfxSlider & keyof IfxSliderAttributes]?: IfxSlider[K] } & { [K in keyof IfxSlider & keyof IfxSliderAttributes as `attr:${K}`]?: IfxSliderAttributes[K] } & { [K in keyof IfxSlider & keyof IfxSliderAttributes as `prop:${K}`]?: IfxSlider[K] };
        "ifx-spinner": Omit<IfxSpinner, keyof IfxSpinnerAttributes> & { [K in keyof IfxSpinner & keyof IfxSpinnerAttributes]?: IfxSpinner[K] } & { [K in keyof IfxSpinner & keyof IfxSpinnerAttributes as `attr:${K}`]?: IfxSpinnerAttributes[K] } & { [K in keyof IfxSpinner & keyof IfxSpinnerAttributes as `prop:${K}`]?: IfxSpinner[K] };
        "ifx-status": Omit<IfxStatus, keyof IfxStatusAttributes> & { [K in keyof IfxStatus & keyof IfxStatusAttributes]?: IfxStatus[K] } & { [K in keyof IfxStatus & keyof IfxStatusAttributes as `attr:${K}`]?: IfxStatusAttributes[K] } & { [K in keyof IfxStatus & keyof IfxStatusAttributes as `prop:${K}`]?: IfxStatus[K] };
        "ifx-step": Omit<IfxStep, keyof IfxStepAttributes> & { [K in keyof IfxStep & keyof IfxStepAttributes]?: IfxStep[K] } & { [K in keyof IfxStep & keyof IfxStepAttributes as `attr:${K}`]?: IfxStepAttributes[K] } & { [K in keyof IfxStep & keyof IfxStepAttributes as `prop:${K}`]?: IfxStep[K] };
        "ifx-stepper": Omit<IfxStepper, keyof IfxStepperAttributes> & { [K in keyof IfxStepper & keyof IfxStepperAttributes]?: IfxStepper[K] } & { [K in keyof IfxStepper & keyof IfxStepperAttributes as `attr:${K}`]?: IfxStepperAttributes[K] } & { [K in keyof IfxStepper & keyof IfxStepperAttributes as `prop:${K}`]?: IfxStepper[K] };
        "ifx-switch": Omit<IfxSwitch, keyof IfxSwitchAttributes> & { [K in keyof IfxSwitch & keyof IfxSwitchAttributes]?: IfxSwitch[K] } & { [K in keyof IfxSwitch & keyof IfxSwitchAttributes as `attr:${K}`]?: IfxSwitchAttributes[K] } & { [K in keyof IfxSwitch & keyof IfxSwitchAttributes as `prop:${K}`]?: IfxSwitch[K] };
        "ifx-tab": Omit<IfxTab, keyof IfxTabAttributes> & { [K in keyof IfxTab & keyof IfxTabAttributes]?: IfxTab[K] } & { [K in keyof IfxTab & keyof IfxTabAttributes as `attr:${K}`]?: IfxTabAttributes[K] } & { [K in keyof IfxTab & keyof IfxTabAttributes as `prop:${K}`]?: IfxTab[K] };
        "ifx-table": Omit<IfxTable, keyof IfxTableAttributes> & { [K in keyof IfxTable & keyof IfxTableAttributes]?: IfxTable[K] } & { [K in keyof IfxTable & keyof IfxTableAttributes as `attr:${K}`]?: IfxTableAttributes[K] } & { [K in keyof IfxTable & keyof IfxTableAttributes as `prop:${K}`]?: IfxTable[K] };
        "ifx-tabs": Omit<IfxTabs, keyof IfxTabsAttributes> & { [K in keyof IfxTabs & keyof IfxTabsAttributes]?: IfxTabs[K] } & { [K in keyof IfxTabs & keyof IfxTabsAttributes as `attr:${K}`]?: IfxTabsAttributes[K] } & { [K in keyof IfxTabs & keyof IfxTabsAttributes as `prop:${K}`]?: IfxTabs[K] };
        "ifx-template": Omit<IfxTemplate, keyof IfxTemplateAttributes> & { [K in keyof IfxTemplate & keyof IfxTemplateAttributes]?: IfxTemplate[K] } & { [K in keyof IfxTemplate & keyof IfxTemplateAttributes as `attr:${K}`]?: IfxTemplateAttributes[K] } & { [K in keyof IfxTemplate & keyof IfxTemplateAttributes as `prop:${K}`]?: IfxTemplate[K] };
        "ifx-templates-ui": IfxTemplatesUi;
        "ifx-text-field": Omit<IfxTextField, keyof IfxTextFieldAttributes> & { [K in keyof IfxTextField & keyof IfxTextFieldAttributes]?: IfxTextField[K] } & { [K in keyof IfxTextField & keyof IfxTextFieldAttributes as `attr:${K}`]?: IfxTextFieldAttributes[K] } & { [K in keyof IfxTextField & keyof IfxTextFieldAttributes as `prop:${K}`]?: IfxTextField[K] };
        "ifx-textarea": Omit<IfxTextarea, keyof IfxTextareaAttributes> & { [K in keyof IfxTextarea & keyof IfxTextareaAttributes]?: IfxTextarea[K] } & { [K in keyof IfxTextarea & keyof IfxTextareaAttributes as `attr:${K}`]?: IfxTextareaAttributes[K] } & { [K in keyof IfxTextarea & keyof IfxTextareaAttributes as `prop:${K}`]?: IfxTextarea[K] };
        "ifx-tooltip": Omit<IfxTooltip, keyof IfxTooltipAttributes> & { [K in keyof IfxTooltip & keyof IfxTooltipAttributes]?: IfxTooltip[K] } & { [K in keyof IfxTooltip & keyof IfxTooltipAttributes as `attr:${K}`]?: IfxTooltipAttributes[K] } & { [K in keyof IfxTooltip & keyof IfxTooltipAttributes as `prop:${K}`]?: IfxTooltip[K] };
        "ifx-tree-view": Omit<IfxTreeView, keyof IfxTreeViewAttributes> & { [K in keyof IfxTreeView & keyof IfxTreeViewAttributes]?: IfxTreeView[K] } & { [K in keyof IfxTreeView & keyof IfxTreeViewAttributes as `attr:${K}`]?: IfxTreeViewAttributes[K] } & { [K in keyof IfxTreeView & keyof IfxTreeViewAttributes as `prop:${K}`]?: IfxTreeView[K] };
        "ifx-tree-view-item": Omit<IfxTreeViewItem, keyof IfxTreeViewItemAttributes> & { [K in keyof IfxTreeViewItem & keyof IfxTreeViewItemAttributes]?: IfxTreeViewItem[K] } & { [K in keyof IfxTreeViewItem & keyof IfxTreeViewItemAttributes as `attr:${K}`]?: IfxTreeViewItemAttributes[K] } & { [K in keyof IfxTreeViewItem & keyof IfxTreeViewItemAttributes as `prop:${K}`]?: IfxTreeViewItem[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "ifx-accordion": LocalJSX.IntrinsicElements["ifx-accordion"] & JSXBase.HTMLAttributes<HTMLIfxAccordionElement>;
            "ifx-accordion-item": LocalJSX.IntrinsicElements["ifx-accordion-item"] & JSXBase.HTMLAttributes<HTMLIfxAccordionItemElement>;
            "ifx-action-list": LocalJSX.IntrinsicElements["ifx-action-list"] & JSXBase.HTMLAttributes<HTMLIfxActionListElement>;
            "ifx-action-list-item": LocalJSX.IntrinsicElements["ifx-action-list-item"] & JSXBase.HTMLAttributes<HTMLIfxActionListItemElement>;
            "ifx-ai-label": LocalJSX.IntrinsicElements["ifx-ai-label"] & JSXBase.HTMLAttributes<HTMLIfxAiLabelElement>;
            "ifx-alert": LocalJSX.IntrinsicElements["ifx-alert"] & JSXBase.HTMLAttributes<HTMLIfxAlertElement>;
            "ifx-basic-table": LocalJSX.IntrinsicElements["ifx-basic-table"] & JSXBase.HTMLAttributes<HTMLIfxBasicTableElement>;
            "ifx-breadcrumb": LocalJSX.IntrinsicElements["ifx-breadcrumb"] & JSXBase.HTMLAttributes<HTMLIfxBreadcrumbElement>;
            "ifx-breadcrumb-item": LocalJSX.IntrinsicElements["ifx-breadcrumb-item"] & JSXBase.HTMLAttributes<HTMLIfxBreadcrumbItemElement>;
            "ifx-breadcrumb-item-label": LocalJSX.IntrinsicElements["ifx-breadcrumb-item-label"] & JSXBase.HTMLAttributes<HTMLIfxBreadcrumbItemLabelElement>;
            "ifx-button": LocalJSX.IntrinsicElements["ifx-button"] & JSXBase.HTMLAttributes<HTMLIfxButtonElement>;
            "ifx-card": LocalJSX.IntrinsicElements["ifx-card"] & JSXBase.HTMLAttributes<HTMLIfxCardElement>;
            "ifx-card-headline": LocalJSX.IntrinsicElements["ifx-card-headline"] & JSXBase.HTMLAttributes<HTMLIfxCardHeadlineElement>;
            "ifx-card-image": LocalJSX.IntrinsicElements["ifx-card-image"] & JSXBase.HTMLAttributes<HTMLIfxCardImageElement>;
            "ifx-card-links": LocalJSX.IntrinsicElements["ifx-card-links"] & JSXBase.HTMLAttributes<HTMLIfxCardLinksElement>;
            "ifx-card-overline": LocalJSX.IntrinsicElements["ifx-card-overline"] & JSXBase.HTMLAttributes<HTMLIfxCardOverlineElement>;
            "ifx-card-text": LocalJSX.IntrinsicElements["ifx-card-text"] & JSXBase.HTMLAttributes<HTMLIfxCardTextElement>;
            "ifx-checkbox": LocalJSX.IntrinsicElements["ifx-checkbox"] & JSXBase.HTMLAttributes<HTMLIfxCheckboxElement>;
            "ifx-checkbox-group": LocalJSX.IntrinsicElements["ifx-checkbox-group"] & JSXBase.HTMLAttributes<HTMLIfxCheckboxGroupElement>;
            "ifx-chip": LocalJSX.IntrinsicElements["ifx-chip"] & JSXBase.HTMLAttributes<HTMLIfxChipElement>;
            "ifx-chip-item": LocalJSX.IntrinsicElements["ifx-chip-item"] & JSXBase.HTMLAttributes<HTMLIfxChipItemElement>;
            "ifx-content-switcher": LocalJSX.IntrinsicElements["ifx-content-switcher"] & JSXBase.HTMLAttributes<HTMLIfxContentSwitcherElement>;
            "ifx-content-switcher-item": LocalJSX.IntrinsicElements["ifx-content-switcher-item"] & JSXBase.HTMLAttributes<HTMLIfxContentSwitcherItemElement>;
            "ifx-date-picker": LocalJSX.IntrinsicElements["ifx-date-picker"] & JSXBase.HTMLAttributes<HTMLIfxDatePickerElement>;
            "ifx-download": LocalJSX.IntrinsicElements["ifx-download"] & JSXBase.HTMLAttributes<HTMLIfxDownloadElement>;
            "ifx-dropdown": LocalJSX.IntrinsicElements["ifx-dropdown"] & JSXBase.HTMLAttributes<HTMLIfxDropdownElement>;
            "ifx-dropdown-header": LocalJSX.IntrinsicElements["ifx-dropdown-header"] & JSXBase.HTMLAttributes<HTMLIfxDropdownHeaderElement>;
            "ifx-dropdown-item": LocalJSX.IntrinsicElements["ifx-dropdown-item"] & JSXBase.HTMLAttributes<HTMLIfxDropdownItemElement>;
            "ifx-dropdown-menu": LocalJSX.IntrinsicElements["ifx-dropdown-menu"] & JSXBase.HTMLAttributes<HTMLIfxDropdownMenuElement>;
            "ifx-dropdown-separator": LocalJSX.IntrinsicElements["ifx-dropdown-separator"] & JSXBase.HTMLAttributes<HTMLIfxDropdownSeparatorElement>;
            "ifx-dropdown-trigger": LocalJSX.IntrinsicElements["ifx-dropdown-trigger"] & JSXBase.HTMLAttributes<HTMLIfxDropdownTriggerElement>;
            "ifx-dropdown-trigger-button": LocalJSX.IntrinsicElements["ifx-dropdown-trigger-button"] & JSXBase.HTMLAttributes<HTMLIfxDropdownTriggerButtonElement>;
            "ifx-faq": LocalJSX.IntrinsicElements["ifx-faq"] & JSXBase.HTMLAttributes<HTMLIfxFaqElement>;
            "ifx-file-upload": LocalJSX.IntrinsicElements["ifx-file-upload"] & JSXBase.HTMLAttributes<HTMLIfxFileUploadElement>;
            "ifx-filter-accordion": LocalJSX.IntrinsicElements["ifx-filter-accordion"] & JSXBase.HTMLAttributes<HTMLIfxFilterAccordionElement>;
            "ifx-filter-bar": LocalJSX.IntrinsicElements["ifx-filter-bar"] & JSXBase.HTMLAttributes<HTMLIfxFilterBarElement>;
            "ifx-filter-search": LocalJSX.IntrinsicElements["ifx-filter-search"] & JSXBase.HTMLAttributes<HTMLIfxFilterSearchElement>;
            "ifx-filter-type-group": LocalJSX.IntrinsicElements["ifx-filter-type-group"] & JSXBase.HTMLAttributes<HTMLIfxFilterTypeGroupElement>;
            "ifx-footer": LocalJSX.IntrinsicElements["ifx-footer"] & JSXBase.HTMLAttributes<HTMLIfxFooterElement>;
            "ifx-footer-column": LocalJSX.IntrinsicElements["ifx-footer-column"] & JSXBase.HTMLAttributes<HTMLIfxFooterColumnElement>;
            "ifx-icon": LocalJSX.IntrinsicElements["ifx-icon"] & JSXBase.HTMLAttributes<HTMLIfxIconElement>;
            "ifx-icon-button": LocalJSX.IntrinsicElements["ifx-icon-button"] & JSXBase.HTMLAttributes<HTMLIfxIconButtonElement>;
            "ifx-icons-preview": LocalJSX.IntrinsicElements["ifx-icons-preview"] & JSXBase.HTMLAttributes<HTMLIfxIconsPreviewElement>;
            "ifx-indicator": LocalJSX.IntrinsicElements["ifx-indicator"] & JSXBase.HTMLAttributes<HTMLIfxIndicatorElement>;
            "ifx-link": LocalJSX.IntrinsicElements["ifx-link"] & JSXBase.HTMLAttributes<HTMLIfxLinkElement>;
            "ifx-list": LocalJSX.IntrinsicElements["ifx-list"] & JSXBase.HTMLAttributes<HTMLIfxListElement>;
            "ifx-list-entry": LocalJSX.IntrinsicElements["ifx-list-entry"] & JSXBase.HTMLAttributes<HTMLIfxListEntryElement>;
            "ifx-modal": LocalJSX.IntrinsicElements["ifx-modal"] & JSXBase.HTMLAttributes<HTMLIfxModalElement>;
            "ifx-multiselect": LocalJSX.IntrinsicElements["ifx-multiselect"] & JSXBase.HTMLAttributes<HTMLIfxMultiselectElement>;
            "ifx-multiselect-option": LocalJSX.IntrinsicElements["ifx-multiselect-option"] & JSXBase.HTMLAttributes<HTMLIfxMultiselectOptionElement>;
            "ifx-navbar": LocalJSX.IntrinsicElements["ifx-navbar"] & JSXBase.HTMLAttributes<HTMLIfxNavbarElement>;
            "ifx-navbar-item": LocalJSX.IntrinsicElements["ifx-navbar-item"] & JSXBase.HTMLAttributes<HTMLIfxNavbarItemElement>;
            "ifx-navbar-profile": LocalJSX.IntrinsicElements["ifx-navbar-profile"] & JSXBase.HTMLAttributes<HTMLIfxNavbarProfileElement>;
            "ifx-notification": LocalJSX.IntrinsicElements["ifx-notification"] & JSXBase.HTMLAttributes<HTMLIfxNotificationElement>;
            "ifx-overview-table": LocalJSX.IntrinsicElements["ifx-overview-table"] & JSXBase.HTMLAttributes<HTMLIfxOverviewTableElement>;
            "ifx-pagination": LocalJSX.IntrinsicElements["ifx-pagination"] & JSXBase.HTMLAttributes<HTMLIfxPaginationElement>;
            "ifx-popover": LocalJSX.IntrinsicElements["ifx-popover"] & JSXBase.HTMLAttributes<HTMLIfxPopoverElement>;
            "ifx-progress-bar": LocalJSX.IntrinsicElements["ifx-progress-bar"] & JSXBase.HTMLAttributes<HTMLIfxProgressBarElement>;
            "ifx-radio-button": LocalJSX.IntrinsicElements["ifx-radio-button"] & JSXBase.HTMLAttributes<HTMLIfxRadioButtonElement>;
            "ifx-radio-button-group": LocalJSX.IntrinsicElements["ifx-radio-button-group"] & JSXBase.HTMLAttributes<HTMLIfxRadioButtonGroupElement>;
            "ifx-search-bar": LocalJSX.IntrinsicElements["ifx-search-bar"] & JSXBase.HTMLAttributes<HTMLIfxSearchBarElement>;
            "ifx-search-field": LocalJSX.IntrinsicElements["ifx-search-field"] & JSXBase.HTMLAttributes<HTMLIfxSearchFieldElement>;
            "ifx-segment": LocalJSX.IntrinsicElements["ifx-segment"] & JSXBase.HTMLAttributes<HTMLIfxSegmentElement>;
            "ifx-segmented-control": LocalJSX.IntrinsicElements["ifx-segmented-control"] & JSXBase.HTMLAttributes<HTMLIfxSegmentedControlElement>;
            "ifx-select": LocalJSX.IntrinsicElements["ifx-select"] & JSXBase.HTMLAttributes<HTMLIfxSelectElement>;
            "ifx-set-filter": LocalJSX.IntrinsicElements["ifx-set-filter"] & JSXBase.HTMLAttributes<HTMLIfxSetFilterElement>;
            "ifx-sidebar": LocalJSX.IntrinsicElements["ifx-sidebar"] & JSXBase.HTMLAttributes<HTMLIfxSidebarElement>;
            "ifx-sidebar-item": LocalJSX.IntrinsicElements["ifx-sidebar-item"] & JSXBase.HTMLAttributes<HTMLIfxSidebarItemElement>;
            "ifx-sidebar-title": LocalJSX.IntrinsicElements["ifx-sidebar-title"] & JSXBase.HTMLAttributes<HTMLIfxSidebarTitleElement>;
            "ifx-slider": LocalJSX.IntrinsicElements["ifx-slider"] & JSXBase.HTMLAttributes<HTMLIfxSliderElement>;
            "ifx-spinner": LocalJSX.IntrinsicElements["ifx-spinner"] & JSXBase.HTMLAttributes<HTMLIfxSpinnerElement>;
            "ifx-status": LocalJSX.IntrinsicElements["ifx-status"] & JSXBase.HTMLAttributes<HTMLIfxStatusElement>;
            "ifx-step": LocalJSX.IntrinsicElements["ifx-step"] & JSXBase.HTMLAttributes<HTMLIfxStepElement>;
            "ifx-stepper": LocalJSX.IntrinsicElements["ifx-stepper"] & JSXBase.HTMLAttributes<HTMLIfxStepperElement>;
            /**
             * A toggle switch component for binary on/off states.
             * This component is form-associated, meaning it can participate in HTML forms
             * just like native form controls. It supports form validation, form reset,
             * and browser autofill/restore functionality.
             * Code organization follows the Stencil Style Guide:
             * https://stenciljs.com/docs/style-guide
             * 1. Own Properties (internal, not exposed)
             * 2.
             * @Element (reference to host)
             * 3.
             * @State (internal reactive state)
             * 4.
             * @Prop (public API properties)
             * 5.
             * @Event (emitted events)
             * 6. Lifecycle methods
             * 7.
             * @Listen decorators
             * 8.
             * @Method (public methods)
             * 9. Private methods
             * 10. render()
             * Framework Integration:
             * - Vue: Supports v-model binding on the 'checked' property
             * - Angular: Supports [(ngModel)] and reactive forms (formControl)
             * - React: Standard prop binding and event handling
             * Configuration in stencil.config.ts enables framework-specific bindings.
             */
            "ifx-switch": LocalJSX.IntrinsicElements["ifx-switch"] & JSXBase.HTMLAttributes<HTMLIfxSwitchElement>;
            "ifx-tab": LocalJSX.IntrinsicElements["ifx-tab"] & JSXBase.HTMLAttributes<HTMLIfxTabElement>;
            "ifx-table": LocalJSX.IntrinsicElements["ifx-table"] & JSXBase.HTMLAttributes<HTMLIfxTableElement>;
            "ifx-tabs": LocalJSX.IntrinsicElements["ifx-tabs"] & JSXBase.HTMLAttributes<HTMLIfxTabsElement>;
            "ifx-template": LocalJSX.IntrinsicElements["ifx-template"] & JSXBase.HTMLAttributes<HTMLIfxTemplateElement>;
            "ifx-templates-ui": LocalJSX.IntrinsicElements["ifx-templates-ui"] & JSXBase.HTMLAttributes<HTMLIfxTemplatesUiElement>;
            "ifx-text-field": LocalJSX.IntrinsicElements["ifx-text-field"] & JSXBase.HTMLAttributes<HTMLIfxTextFieldElement>;
            "ifx-textarea": LocalJSX.IntrinsicElements["ifx-textarea"] & JSXBase.HTMLAttributes<HTMLIfxTextareaElement>;
            "ifx-tooltip": LocalJSX.IntrinsicElements["ifx-tooltip"] & JSXBase.HTMLAttributes<HTMLIfxTooltipElement>;
            "ifx-tree-view": LocalJSX.IntrinsicElements["ifx-tree-view"] & JSXBase.HTMLAttributes<HTMLIfxTreeViewElement>;
            "ifx-tree-view-item": LocalJSX.IntrinsicElements["ifx-tree-view-item"] & JSXBase.HTMLAttributes<HTMLIfxTreeViewItemElement>;
        }
    }
}
