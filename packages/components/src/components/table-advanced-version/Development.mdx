import { Meta, Controls, Canvas } from '@storybook/addon-docs/blocks';
import * as TableStories from './table.stories';
 
<Meta of={TableStories} />

# Table

<Canvas of={TableStories.DefaultState} sourceState="shown" />

<Controls />


## Stories

### Including client-side pagination
<Canvas of={TableStories.Pagination} sourceState="shown" />

### Including server-side pagination
<Canvas of={TableStories.ServerSidePagination} sourceState="shown" />

Server-side pagination is implemented by exposing the serverPageChangeHandler property. The property takes a function. The function doesn't contain the data - it FETCHES the data when called.
Your function is called fresh each time - it doesn't store data, it fetches it. The component handles when to call it, you handle what data to return.

Example of a function you would pass to the serverPageChangeHandler prop:

```javascript
table.serverPageChangeHandler = async ({ page, pageSize }) => {
  const response = await fetch(`/api/cars?page=${page}&size=${pageSize}`);
  const data = await response.json();
  
  return {
    rows: data.cars,
    total: data.totalCount
  };
};
```

### Including custom components

#### Example: Including a button column

<Canvas of={TableStories.IncludesButtons} sourceState="shown" />

<b>Adding the button event handler in Angular:</b> 

 ```js
// in the component.ts file:
  buttonRendererOptions = {
    onButtonClick: (params: any, event: Event) => {
      console.log("button clicked", params.data);
    }
  };
// in the component.html file:
  <h3>Table with button</h3>
  <ifx-table
    row-height="default"
    cols='[{"headerName":"Make","field":"make","sortable":true,"sort":"desc","unSortIcon":true},{"headerName":"Model","field":"model","sortable":true,"unSortIcon":true},{"headerName":"Price","field":"price"},{"headerName":"Age","field":"age"},{"headerName":"","field":"button"}]'
    rows='[{"make":"Toyota","model":"Celica","price":35000,"age":10,"button":{"disabled":false,"variant":"secondary","size":"s","target":"_blank","href":"https://www.w3schools.com/","theme":"default","type":"button","fullWidth":true,"text":"Toyota Button"}},{"make":"Ford","model":"Mondeo","price":32000,"age":12,"button":{"disabled":false,"variant":"secondary","size":"s","target":"_blank","href":"https://www.w3schools.com/","theme":"default","type":"button","fullWidth":true,"text":"Ford Button"}},{"make":"Porsche","model":"Boxster","price":72000,"button":{"disabled":false,"variant":"secondary","size":"s","target":"_blank","href":"https://www.w3schools.com/","theme":"default","type":"button","fullWidth":true,"text":"Porsche Button"}}]'
    [buttonRendererOptions]="buttonRendererOptions"
    table-height="auto"
    pagination="false"
    filter-orientation="none">
</ifx-table>
```

<b>Adding the button event handler in React:</b> 

```js
function App() {
  const tableRef = useRef(null);

  useEffect(() => {
    if (tableRef.current) {
      tableRef.current.buttonRendererOptions = {
        onButtonClick: (params, event) => console.log('Button clicked:', params.data)
      };
    }
  }, []);

  return (
    <ifx-table
      cols={[{headerName: "Make", field: "make"}, ...]}
      rows={[{make: "Toyota", ...}]}
      ref={tableRef}
      row-height="default"
      table-height="auto"
      pagination="false"
      filter-orientation="none"
    ></ifx-table>
  );
}
```

<b>Adding the button event handler in Vanilla/PlainJs:</b> 

```js
document.addEventListener('DOMContentLoaded', () => {
    const tableWithBtn = document.querySelector('#table-with-btn');

    tableWithBtn.buttonRendererOptions = {
      onButtonClick: (params, event) => {
        console.log("button clicked", params.data);
      }
    };
});
```
<b>Adding the button event handler in Vue:</b> 

Using ```v-if``` to ensure all data is set before rendering the table. There are other ways to guarantee data readiness, but this is the solution we have tested and used in our example applications.
```js
//template
    <ifx-table
      v-if="ready"
      :cols="tableColumnsWithBtn"
      :rows="tableRowsWithBtn"
      :buttonRendererOptions="buttonRendererOptions"
      row-height="default"
      table-height="auto"
      pagination="false"
      filter-orientation="none">
    </ifx-table>

//script
<script>
export default {
  data() {
    return {
       tableColumnsWithBtn: [
        { headerName: "Make", field: "make", sortable: true, sort: "desc", unSortIcon: true },
        { headerName: "Model", field: "model", sortable: true, unSortIcon: true },
        { headerName: "Price", field: "price" },
        { headerName: "Age", field: "age" },
        { headerName: "", field: "button" }
      ],
      // Define your rows
      tableRowsWithBtn: [
        {
          make: "Toyota",
          model: "Celica",
          price: 35000,
          age: 10,
          button: {
            disabled: false,
            variant: "secondary",
            size: "s",
            target: "_blank",
            href: "https://www.w3schools.com/",
            theme: "default",
            type: "button",
            fullWidth: true,
            text: "Toyota Button"
          }
        },
       ],
       buttonRendererOptions: {
        onButtonClick: (params, event) => {
          console.log('Button clicked:', params.data);
         }
      },
       ready: false
    };
  },
  mounted() {
     // Ensure all data is set before rendering the table
    this.ready = true;
  }
};
</script>
```

<b>Nesting the tooltip component</b> 

For simplicity purposes, the ```variant``` and ```icon``` properties have been removed from the tooltip integration into the table. 

```js 
  "tooltipInfo": {
    "value": "Table cell text",
    "text": "tooltip text",
    "position": "top"
  }
```

#### Currently supported nestable components:
- ifx-button
- ifx-status
- ifx-icon-button
- ifx-link
- ifx-tooltip

#### Example: Including inner buttons
<Canvas of={TableStories.IncludesInnerButtons} sourceState="shown" />

### Sidebar filter

<Canvas of={TableStories.SidebarFilter} sourceState="shown" />

Advanced filtering can be done including our set-filter component via a named slot within the table.
The set filter can be of type 'text', 'single-select', or 'multi-select'. An additional type to offer filtering using chips will be available in the future.
Filtering using our select components requires an input array in the following format:


```
const options = [{
  value: "a",
  label: "option a",
  selected: false
},
{
  value: "b",
  label: "option b",
  selected: false
},
{
  value: "c",
  label: "option c",
  selected: false
}];
```


### Topbar filter

<Canvas of={TableStories.TopbarFilter} sourceState="shown" />

Advanced filtering can be done including our set-filter component via a named slot within the table.
The set filter can be of type 'text', 'single-select', or 'multi-select'. An additional type to offer filtering using chips will be available in the future.
Filtering using our select components requires an input array in the following format:


```
const options = [{
  value: "a",
  label: "option a",
  selected: false
},
{
  value: "b",
  label: "option b",
  selected: false
},
{
  value: "c",
  label: "option c",
  selected: false
}];
```